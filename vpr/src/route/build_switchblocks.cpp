/*
 * Author(s): Oleg Petelin
 * Last revised: September, 2015
 *
 ************ NEW SWITCH BLOCK HIGH-LEVEL DESCRIPTION ************
 * The new switch block description format allows a much finer level of control over the switch blocks generated by VPR.
 * Whereas a user previously only had the choice of 'wilton', 'universal', 'subset', or 'full' switch blocks, the new
 * format allows a user to specify a small set of mathematical formulas that describe the switch block connections. This format
 * allows the specification of all the switch blocks previously available in VPR as well as a great number of new switch block patterns.
 *
 * The new switch block description format is loosely based on chapter 7 of Lemieux' and Lewis' "Design of Interconnection Networks
 * for Programmable Logic" book (2004).
 *
 *
 ************ FILES AND THEIR PURPOSE ************
 * The overall flow of parsing and building the new switch blocks involves reading switch block descriptions from the VPR
 * architecture file and then building the switch blocks according to these descriptions in build_rr_graph (rr_graph.c).
 * This functionality is split across different files which are described below:
 *
 * read_xml_arch_file.c (under libarchfpga):
 * calls ProcessSwitchblocks which fills s_arch-->switchblocks with info about each user-defined switch blocks
 * calls functions from parse_switchblocks.c to build switch block data structures (reads-in permutation functions
 * and wire segment source/dest connection info)
 * ProcessSegments has been modified to give a string name to each segment type (in t_segment_inf).
 * parse_switchblocks.c (under libarchfpga):
 * provides functions to help load switch block data structures during XML parsing of VPR architecture file
 * provides functions to evaluate switch block permutation formulas and return a numeric result
 * SetupVPR.c:
 * SetupRoutingArch copies switch block information from s_arch to s_det_routing_arch
 * physical_types.h (under libarchfpga):
 * defines classes, structs and typedefs for parsing switch blocks from XML architecture file
 * vpr_types.h
 * s_det_routing_arch carries info about custom switch blocks
 * build_switchblocks.c (this file):
 * builds t_sb_connection_map sparse array containing target connections for each wire in each horizontal/vertical channel segment.
 * 'compute_wire_connections' is the most important function here -- it computes the set of wire segments that a given wire at
 * (x, y, from_side, to_side, from_wire) should connect to.
 * rr_graph.c:
 * calls alloc_and_load_switchblock_permutations (from build_switchblocks.c) which creates the t_sb_connection_map
 * rr_graph2.c:
 * get_wire_to_chan_seg is called within get_wire_to_wires which looks at t_sb_connection_map to create the edges that
 * connect a source wire segment into a destination channel segment
 *
 *
 ************ DESCRIPTION OF SWITCH BLOCK SPECIFICATION ************
 * Some terminology:
 *
 * Wire segment type: a named group of wires defined in the architecture file.
 * Wire subsegment number: a number assigned to a wire subsegment relative to the wire's start coordinate (see diagram below).
 * Used to define a collection of wire segments that have a start point in the same column (or row) of the FPGA.
 * Wire switch point: a number assigned to a specific switch block along a wire segment
 *
 * Ex: for a length-4 unidirectional wire segment going in the decreasing direction:
 * wire switch point    0<-------3<-------2<-------1<-------0
 * wire subsegment #         3        2        1        0
 *
 * The new switch block format allows a user to specify mathematical permutation functions that describe how different types of wires will connect at different switchpoinnts. One or more wire types *and* one or more switch points define a set of wires, and each switch block connection is specified in terms of a source and destination set. Specifically, the permutation functions prescribe how a set of from_type/from_switchpoint wires (the source set) in one channel segment should connect to a set of to_type/to_switchpoint wires (the destination set) in an adjacent channel segment. This provides for an abstract but very flexible way of specifying different switch block patterns.
 *
 * An example from an XML VPR architecture file is given below.
 *
 * The 'wireconn' entries define ordered source/destination sets of wire segments that should be connected with the specified permutation functions. The wireconn entries essentially "re-index" the channel so that a permutation function of 't/2' means that the t'th wire segment in the source wireconn set should connect to the [(t/2)%W]'th wire segment in the destination set where W is the size, or effective channel width, of the destination set (note that permutation functions are implicitly modulo W so that all functions evaluate to a number that indexes into the destination set).
 *
 * <!-- Specify that custom switch blocks will be used. This is backwards compatible with VPR's previous wilton/subset/univeral specification,
 * but "custom" is specified instead. -->
 * <switch_block type="custom"/>			<-- backwards-compatible with VPR's previous wilton/subset/universal/full specification
 * ...
 * ...
 * <!-- Segment specification is as before, except that a "name" is also specified for each segment. Each segment defines a type of wire. -->
 * <segmentlist>
 * <segment freq="0.85" name="l4" length="4" type="unidir" Rmetal="232" Cmetal="0.0">
 * <mux name="l4_mux"/>
 * <sb type="pattern">1 1 1 1 1</sb>
 * <cb type="pattern">1 1 1 1</cb>
 * </segment>
 * <segment freq="0.15" name="l8_global" length="8" type="unidir" Rmetal="33.8" Cmetal="0.0">
 * <mux name="l8_mux"/>
 * <sb type="pattern">1 1 1 1 1 1 1 1 1</sb>
 * <cb type="pattern">1 1 1 1 1 1 1 1</cb>
 * </segment>
 * </segmentlist>
 * ...
 * ...
 * <!-- Custom switch blocks are declared here -->
 * <switchblocklist>
 * <!-- Each "switchblock" entry is given a name. Type specifies either a unidirectional or bidirectional switch block -->
 * <switchblock name="my_switchblock" type="unidir">
 * <!-- Location to implement this switch block (EVERYWHERE/CORE/PERIMETER/CORNER/FRINGE) -->
 * <switchblock_location type="EVERYWHERE"/>
 * <!-- A list of permutation functions. Any number can be specified (for instance two "lt" entries can be specified to increase
 * Fs of connections from the left to the top switch block sides -->
 * <switchfuncs>
 * <!-- "lr" means left-to-right, "lt" means left to top, etc. Formulas support different operators which are discussed later -->
 * <func type="lr" formula="t"/>
 * <func type="lt" formula="W-t"/>
 * <func type="lb" formula="W+t-1"/>
 * <func type="rt" formula="W+t-1"/>
 * <func type="br" formula="W-t-2"/>
 * <func type="bt" formula="t"/>
 * <func type="rl" formula="t"/>
 * <func type="tl" formula="W-t"/>
 * <func type="bl" formula="W+t-1"/>
 * <func type="tr" formula="W+t-1"/>
 * <func type="rb" formula="W-t-2"/>
 * <func type="tb" formula="t"/>
 * </switchfuncs>
 * <!-- Wireconn entries define the sets of wires that should be connected with the above permutation functions -->
 * <wireconn from_type="l4" to_type="l4" from_switchpoint="0,1,2,3" to_switchpoint="0"/>
 * <wireconn from_type="l8_global" to_type="l8_global" from_switchpoint="0,4" to_switchpoint="0"/>
 * <wireconn from_type="l8_global" to_type="l4" from_switchpoint="0,4" to_switchpoint="0"/>
 * </switchblock>
 *
 * <switchblock name="another_switch_block" type="unidir">
 * ... switch block description ...
 * </switchblock>
 * </switchblocklist>
 *
 * Allowed symmbols and operators for the switch block permutation functions are described below (recall
 * that formulas are evaluated in 'parse_switchblocks.c'):
 * "+" -- addition
 * "-" -- subtraction
 * "/" -- division
 * "*" -- multiplication
 * "t" -- index of the wire segment in the source set
 * "W" -- size of the destination set
 *
 */

#include <cstring>
#include <algorithm>
#include <iterator>
#include <iostream>

#include "vtr_assert.h"
#include "vtr_memory.h"
#include "vtr_log.h"

#include "vpr_error.h"

#include "build_switchblocks.h"
#include "physical_types.h"
#include "parse_switchblocks.h"
#include "expr_eval.h"

using namespace std;

/************ Defines ************/
/* if defined, switch block patterns are loaded by first computing a row of switch blocks and then
 * stamping out the row throughout the FPGA */
//#define FAST_SB_COMPUTATION

/* REF_X/REF_Y set a reference coordinate; some look-up structures in this file are computed relative to
 * this reference */
#define REF_X 1 //constexpr int REX_X = 1;	<-- basically C++11 defines; more type-safe
#define REF_Y 1

/************ Function Declarations ************/
#ifdef FAST_SB_COMPUTATION
/* over all connected wire types (i,j), compute the maximum least common multiple of their wire lengths,
 * ie max(LCM(L_i, L_J)) */
static int get_max_lcm(vector<t_switchblock_inf>* switchblocks, t_wire_type_sizes* wire_type_sizes);

/* compute all the switchblocks around the perimeter of the FPGA for the given switchblock and wireconn */
static void compute_perimeter_switchblocks(t_chan_details* chan_details_x, t_chan_details* chan_details_y, vector<t_switchblock_inf>* switchblocks, const DeviceGrid& grid, int nodes_per_chan, t_wire_type_sizes* wire_type_sizes, e_directionality directionality, t_sb_connection_map* sb_conns);

/* computes a horizontal line of switchblocks of size sb_row_size (or of grid.width()-4, whichever is smaller), starting
 * at coordinate (1,1) */
static void compute_switchblock_row(int sb_row_size, t_chan_details* chan_details_x, t_chan_details* chan_details_y, vector<t_switchblock_inf>* switchblocks, const DeviceGrid& grid, int nodes_per_chan, t_wire_type_sizes* wire_type_sizes, e_directionality directionality, t_sb_connection_map* sb_row);

/* stamp out a line of horizontal switchblocks starting at coordinates (ref_x, ref_y) and
 * continuing on for sb_row_size */
static void stampout_switchblocks_from_row(int sb_row_size,
                                           int nodes_per_chan,
                                           const DeviceGrid& grid,
                                           t_wire_type_sizes* wire_type_sizes,
                                           e_directionality directionality,
                                           t_sb_connection_map* sb_row,
                                           t_sb_connection_map* sb_conns);

#endif //FAST_SB_COMPUTATION

/* Compute the wire(s) that the wire at (x, y, from_side, to_side, from_wire) should connect to.
 * sb_conns is updated with the result */
static void compute_wire_connections(int x_coord, int y_coord, enum e_side from_side, enum e_side to_side, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, t_switchblock_inf* sb, const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, e_directionality directionality, t_sb_connection_map* sb_conns, vtr::RandState& rand_state);

/* ... sb_conn represents the 'coordinates' of the desired switch block connections */
static void compute_wireconn_connections(const DeviceGrid& grid, e_directionality directionality, const t_chan_details& from_chan_details, const t_chan_details& to_chan_details, Switchblock_Lookup sb_conn, int from_x, int from_y, int to_x, int to_y, t_rr_type from_chan_type, t_rr_type to_chan_type, t_wire_type_sizes* wire_type_sizes, t_switchblock_inf* sb, t_wireconn_inf* wireconn_ptr, t_sb_connection_map* sb_conns, vtr::RandState& rand_state);

static int evaluate_num_conns_formula(std::string num_conns_formula, int from_wire_count, int to_wire_count);

/* returns the wire indices belonging to the types in 'wire_type_vec' and switchpoints in 'points' at the given channel segment */
static std::vector<t_wire_switchpoint> get_switchpoint_wires(const DeviceGrid& grid, const t_chan_seg_details* chan_details, t_rr_type chan_type, int x, int y, e_side side, const vector<t_wire_switchpoints>& wire_switchpoints_vec, t_wire_type_sizes* wire_type_sizes, bool is_dest, SwitchPointOrder order, vtr::RandState& rand_state);

/* returns the subsegment number of the specified wire at seg_coord*/
static int get_wire_subsegment_num(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details& wire_details, int seg_coord);

int get_wire_segment_length(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details& wire_details);

/* Returns the switchpoint of the wire specified by wire_details at a segment coordinate
 * of seg_coord, and connection to the sb_side of the switchblock */
static int get_switchpoint_of_wire(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details& wire_details, int seg_coord, e_side sb_side);

/* returns true if the coordinates x/y do not correspond to the location specified by 'location' */
static bool sb_not_here(const DeviceGrid& grid, int x, int y, e_sb_location location);

/* checks if the specified coordinates represent a corner of the FPGA */
static bool is_corner(const DeviceGrid& grid, int x, int y);

/* checks if the specified coordinates correspond to one of the perimeter switchblocks */
static bool is_perimeter(const DeviceGrid& grid, int x, int y);

static bool is_perimeter_left(const DeviceGrid& grid, int x, int y);
static bool is_perimeter_right(const DeviceGrid& grid, int x, int y);
static bool is_perimeter_bottom(const DeviceGrid& grid, int x, int y);
static bool is_perimeter_top(const DeviceGrid& grid, int x, int y);

/* checks if the specified coordinates correspond to the core of the FPGA (i.e. not perimeter) */
static bool is_core(const DeviceGrid& grid, int x, int y);

/* adjusts a negative destination wire index calculated from a permutation formula */
static int adjust_formula_result(int dest_wire, int src_W, int dest_W, int connection_ind);

static int get_wire_subsegment_num_gsb(const t_chan_seg_details& wire_details, int seg_coord);
static int get_switchpoint_of_wire_gsb(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details& wire_details, int seg_coord, e_side sb_side);
//************************************for gsb arch*******************************************
static void compute_gsb_wire_connections_seg(int x_coord, int y_coord, enum e_from_type from_type, 
                                                const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                                                t_gsb_inf* gsb, const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, 
                                                t_gsb_connection_map* gsb_conns);

static void compute_gsb_wire_connections_omux(int x_coord, int y_coord, enum e_from_type from_type, 
                                                const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                                                t_gsb_inf* gsb, const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, 
                                                t_gsb_connection_map* gsb_conns);

static void compute_gsb_wire_connections_pb(int x_coord, int y_coord, enum e_from_type from_type, 
                                                const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                                                t_gsb_inf* gsb, const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, 
                                                t_gsb_connection_map* gsb_conns);

static std::vector<int> get_from_node_for_multistage_mux(int x_coord, int y_coord, 
                                                         const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                                                         const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, std::vector<t_mux_same_from_inf> from_mux_inf,
                                                         t_gsb_inf* gsb, const std::map<std::string, std::vector<std::map<int, int>>> other_pbpin_to_clbpin_map);

static void compute_multistage_mux_map(int x_coord, int y_coord,
                                       const t_chan_details& chan_details_x, const t_chan_details& chan_details_y,
                                       t_gsb_inf* gsb, const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes,
                                       t_gsb_multistage_mux_map* gsb_multistage_mux_map,
                                       const std::map<std::string, std::vector<std::map<int, int>>> other_pbpin_to_clbpin_map);

e_side fromdir2side(e_seg_dir seg_dir);
e_side todir2side(e_seg_dir seg_dir);

//get index for from-to index[to_wire_index][from_index_vec_to_this_to_wire]
std::unordered_map<GSB_Side, std::vector<GSB_detail_conn_pb>, t_hash_GSB_side> get_detail_index_for_gsb_pb(const t_common_from_inf* gsb_from, const t_type_ptr clb_type);

std::unordered_map<GSB_Side, std::vector<GSB_detail_conn>, t_hash_GSB_side> get_detail_index_for_gsb(const t_common_from_inf* gsb_from);

//get index for from-to index[to_wire_index][from_index_vec_to_this_to_wire]
std::vector<std::vector<int>> get_from_index_for_gsb(const t_common_from_inf* gsb_from, int total_froms, int to_nums, int itg);

std::vector<std::vector<int>> get_from_index_for_gsb_pb(const t_common_from_inf* gsb_from, int total_froms, int to_nums, const t_type_ptr clb_type, int itg);

static const t_chan_details& index_into_correct_chan_gsb(int tile_x, int tile_y, enum e_seg_dir seg_dir, bool isFrom, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, int* set_x, int* set_y, t_rr_type* chan_type);

static void compute_gsb_from_connections_seg(const DeviceGrid& grid, std::vector<t_wire_switchpoint> potential_dest_wires,
                                             const t_chan_details& from_chan_details, const t_chan_details& to_chan_details,
                                             GSB_Lookup gsb_conn, int from_x, int from_y, int to_x, int to_y,
                                             t_rr_type from_chan_type, t_wire_type_sizes* wire_type_sizes,
                                             const t_common_from_inf* gsb_from,
                                             std::unordered_map<GSB_Side, std::vector<GSB_detail_conn>, t_hash_GSB_side> detail_map, t_gsb_connection_map* gsb_conns,
                                             int itg);

static void compute_gsb_from_connections_omuxOrpb(const DeviceGrid& grid, std::vector<t_wire_switchpoint> potential_dest_wires,
                                                  const t_chan_details& to_chan_details, GSB_Lookup gsb_conn, int to_x, int to_y,
                                                  const t_gsb_from_inf* gsb_from, t_gsb_connection_map* gsb_conns, int itg, 
                                                  std::unordered_map<GSB_Side, std::vector<GSB_detail_conn_pb>, t_hash_GSB_side> detail_map,
                                                  std::string actual_pbtype_name);

static std::vector<t_wire_switchpoint> get_switchpoint_wires_gsb(const DeviceGrid& grid, const t_chan_seg_details* chan_details, t_rr_type chan_type,
                                                                    int x, int y, e_side side, const t_wire_switchpoints& wire_switchpoints, 
                                                                    t_wire_type_sizes* wire_type_sizes, bool is_dest);

//*************************************for gsb two stage mux****************************************************
static void compute_two_stage_mux_map(int x_coord, int y_coord, 
                                      const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                                      t_gsb_inf* gsb,
                                      const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, 
                                      t_two_stage_mux_map* two_stage_mux_map,
                                      const t_potential_wires_map& potential_wires_map,
                                      const std::map<std::string, std::vector<std::map<int, int>>> other_pbpin_to_clbpin_map,
                                      const std::map<std::string, int>& stage_mux_medium_map,
                                      const std::map<int, int>& clbpin_medium_map,
                                      int wire_to_arch_ipin_switch);

static std::vector<int> get_from_node_for_multistage_mux_v2(int x_coord, int y_coord, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                                                         const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, std::vector<t_mux_same_from_inf> from_mux_inf, 
                                                         const std::string first_pb_name, const std::map<std::string, std::vector<std::map<int, int>>> other_pbpin_to_clbpin_map,
                                                         const t_potential_wires_map& potential_wires_map, const std::map<int, int>& clbpin_medium_map);

static void build_wire_map(int x_coord, int y_coord, const DeviceGrid& grid, 
                            const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                            const std::vector<t_segment_inf>& segment_inf, t_wire_type_sizes* wire_type_sizes,
                            t_potential_wires_map& potential_wires_map);

// ************************************for imux arch****************************
static void compute_imux_group_dis(std::string pb_type_name, t_imux_inf* imux, std::vector<std::vector<std::vector<int>>>& clb_ipin_index_group);
int find_port(std::string port_name, t_pb_type* pb_type);

static void compute_imux_wire_connections_seg(int x_coord, int y_coord, enum e_from_type from_type, 
                                                const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                                                t_imux_inf* imux, const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, 
                                                t_gsb_connection_map* gsb_conns, int wire_to_arch_ipin_switch,
                                                const std::vector<std::vector<std::vector<int>>>& clb_ipin_index_group);

static void compute_imux_from_connections_seg(const DeviceGrid& grid, std::vector<std::vector<int>> potential_dest_pins_lut,
                                                const t_chan_details& from_chan_details, GSB_Lookup gsb_conn, int from_x, int from_y,  
                                                t_rr_type from_chan_type, t_wire_type_sizes* wire_type_sizes, const t_common_from_inf* gsb_from,
                                                std::unordered_map<GSB_Side, std::vector<GSB_detail_conn>, t_hash_GSB_side> detail_map, 
                                                t_gsb_connection_map* gsb_conns, int wire_to_arch_ipin_switch);

static void compute_imux_wire_connections_omux(int x_coord, int y_coord, enum e_from_type from_type, t_imux_inf* imux,
                                                t_gsb_connection_map* gsb_conns, const std::vector<std::vector<std::vector<int>>>& clb_ipin_index_group, 
                                                int wire_to_arch_ipin_switch);

static void compute_imux_wire_connections_pb(int x_coord, int y_coord, const DeviceGrid& grid, enum e_from_type from_type,
                                                t_imux_inf* imux, t_gsb_connection_map* gsb_conns, 
                                                const std::vector<std::vector<std::vector<int>>>& clb_ipin_index_group,
                                                int wire_to_arch_ipin_switch);

static void compute_imux_from_connections_omuxOrpb(std::vector<std::vector<int>> potential_dest_pins_lut,
                                                   GSB_Lookup gsb_conn,
                                                   const t_common_from_inf* gsb_from,
                                                   t_type_ptr clb_type,
                                                   t_gsb_connection_map* gsb_conns,
                                                   int wire_to_arch_ipin_switch,
                                                   std::unordered_map<GSB_Side, std::vector<GSB_detail_conn_pb>, t_hash_GSB_side> detail_map);

/************ Function Definitions ************/
/* allocate and build the switchblock permutation map */
t_sb_connection_map* alloc_and_load_switchblock_permutations(const t_chan_details& chan_details_x,
                                                             const t_chan_details& chan_details_y,
                                                             const DeviceGrid& grid,
                                                             vector<t_switchblock_inf> switchblocks,
                                                             t_chan_width* nodes_per_chan,
                                                             e_directionality directionality,
                                                             vtr::RandState& rand_state) {
    /* get a single number for channel width */
    int channel_width = nodes_per_chan->max;
    if (nodes_per_chan->max != nodes_per_chan->x_min || nodes_per_chan->max != nodes_per_chan->y_min) {
        vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "Custom switch blocks currently support consistent channel widths only.");
    }

    /* sparse array that will contain switch block connections */
    t_sb_connection_map* sb_conns = new t_sb_connection_map;

    /* We assume that x & y channels have the same ratios of wire types. i.e., looking at a single
     * channel is representative of all channels in the FPGA -- as of 3/9/2013 this is true in VPR */
    t_wire_type_sizes wire_type_sizes;
    count_wire_type_sizes(chan_details_x[0][0].data(), channel_width, &wire_type_sizes);

#ifdef FAST_SB_COMPUTATION
    /******** fast switch block computation method; computes a row of switchblocks then stamps it out everywhere ********/
    /* figure out max(lcm(L_i, L_j)) for all wire lengths belonging to wire types i & j */
    int max_lcm = get_max_lcm(&switchblocks, &wire_type_sizes);
    t_sb_connection_map sb_row;

    /* compute the perimeter switchblocks. unfortunately we can't just compute corners and stamp out the rest because
     * for a unidirectional architecture corners AND perimeter switchblocks require special treatment */
    compute_perimeter_switchblocks(chan_details_x, chan_details_y, &switchblocks,
                                   grid, channel_width, &wire_type_sizes, directionality, sb_conns);

    /* compute the switchblock row */
    compute_switchblock_row(max_lcm, chan_details_x, chan_details_y, &switchblocks,
                            grid, channel_width, &wire_type_sizes, directionality, &sb_row);

    /* stamp-out the switchblock row throughout the rest of the FPGA */
    stampout_switchblocks_from_row(max_lcm, channel_width,
                                   grid, &wire_type_sizes, directionality, &sb_row, sb_conns);

#else
    /******** slow switch block computation method; computes switchblocks at each coordinate ********/
    /* iterate over all the switchblocks specified in the architecture */
    for (int i_sb = 0; i_sb < (int)switchblocks.size(); i_sb++) {
        t_switchblock_inf sb = switchblocks[i_sb];

        /* verify that switchblock type matches specified directionality -- currently we have to stay consistent */
        if (directionality != sb.directionality) {
            vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "alloc_and_load_switchblock_connections: Switchblock %s does not match directionality of architecture\n", sb.name.c_str());
        }
        /* Iterate over the x,y coordinates spanning the FPGA. */
        for (size_t x_coord = 0; x_coord < grid.width(); x_coord++) {
            for (size_t y_coord = 0; y_coord <= grid.height(); y_coord++) {
                if (sb_not_here(grid, x_coord, y_coord, sb.location)) {
                    continue;
                }
                /* now we iterate over all the potential side1->side2 connections */
                for (e_side from_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                    for (e_side to_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                        /* Fill appropriate entry of the sb_conns map with vector specifying the wires
                         * the current wire will connect to */
                        compute_wire_connections(x_coord, y_coord, from_side, to_side,
                                                 chan_details_x, chan_details_y, &sb, grid,
                                                 &wire_type_sizes, directionality, sb_conns, rand_state);
                    }
                }
            }
        }
    }
#endif

    return sb_conns;
}

/* deallocates switch block connections sparse array */
void free_switchblock_permutations(t_sb_connection_map* sb_conns) {
    sb_conns->clear();
    delete sb_conns;
    sb_conns = nullptr;
    /* the switch block unordered_map can get quite large and it doesn't seem like the program
     * is interested in releasing the memory back to the OS after the map is cleared.
     * calling malloc_trim forces the program to give unused heap space back to the OS.
     * this significantly reduces memory usage during the routing stage when running multiple
     * large benchmark circuits in parallel. */
    vtr::malloc_trim(0);
    return;
}

#ifdef FAST_SB_COMPUTATION
/* over all connected wire types (i,j), compute the maximum least common multiple of their wire lengths,
 * ie max(LCM(L_i, L_J)) */
static int get_max_lcm(vector<t_switchblock_inf>* switchblocks, t_wire_type_sizes* wire_type_sizes) {
    int max_lcm = -1;
    int num_sb = (int)switchblocks->size();

    /* over each switchblock */
    for (int isb = 0; isb < num_sb; isb++) {
        t_switchblock_inf* sb = &(switchblocks->at(isb));
        int num_wireconns = (int)sb->wireconns.size();
        /* over each wireconn */
        for (int iwc = 0; iwc < num_wireconns; iwc++) {
            t_wireconn_inf* wc = &(sb->wireconns[iwc]);
            int num_from_types = (int)wc->from_type.size();
            int num_to_types = (int)wc->to_type.size();
            /* over each from type */
            for (int ifrom = 0; ifrom < num_from_types; ifrom++) {
                /* over each to type */
                for (int ito = 0; ito < num_to_types; ito++) {
                    if ((*wire_type_sizes).find(wc->from_type[ifrom]) != (*wire_type_sizes).end() && (*wire_type_sizes).find(wc->to_type[ito]) != (*wire_type_sizes).end()) {
                        // the condition can fail if freq of a seg is 0 (so it is in wc, but not in wire_type_size)
                        int length1 = wire_type_sizes->at(wc->from_type[ifrom]).length;
                        int length2 = wire_type_sizes->at(wc->to_type[ito]).length;
                        int current_lcm = vtr::lcm(length1, length2);
                        if (current_lcm > max_lcm) {
                            max_lcm = current_lcm;
                        }
                    }
                }
            }
        }
    }

    return max_lcm;
}

/* computes a horizontal row of switchblocks of size sb_row_size (or of grid.width()-4, whichever is smaller), starting
 * at coordinate (1,1) */
static void compute_switchblock_row(int sb_row_size, t_chan_details* chan_details_x, t_chan_details* chan_details_y, vector<t_switchblock_inf>* switchblocks, const DeviceGrid& grid, int nodes_per_chan, t_wire_type_sizes* wire_type_sizes, e_directionality directionality, t_sb_connection_map* sb_row) {
    int y = 1;
    for (int isb = 0; isb < (int)switchblocks->size(); isb++) {
        t_switchblock_inf* sb = &(switchblocks->at(isb));
        for (int x = 1; x < 1 + sb_row_size; x++) {
            if (sb_not_here(grid, x, y, sb->location)) {
                continue;
            }
            /* now we iterate over all the potential side1->side2 connections */
            for (e_side from_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                for (e_side to_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                    /* Fill appropriate entry of the sb_conns map with vector specifying the wires
                     * the current wire will connect to */
                    compute_wire_connections(x, y, from_side, to_side,
                                             chan_details_x, chan_details_y, sb, grid,
                                             wire_type_sizes, directionality, sb_row);
                }
            }
        }
    }
}

/* stamp out a row of horizontal switchblocks throughout the FPGA starting at coordinates (ref_x, ref_y) and
 * continuing on for sb_row_size */
static void stampout_switchblocks_from_row(int sb_row_size,
                                           int nodes_per_chan,
                                           const DeviceGrid& grid,
                                           t_wire_type_sizes* wire_type_sizes,
                                           e_directionality directionality,
                                           t_sb_connection_map* sb_row,
                                           t_sb_connection_map* sb_conns) {
    /* over all x coordinates that may need stamping out */
    for (int x = 1; x < grid.width() - 2; x++) { //-2 for no perim channels
        /* over all y coordinates that may need stamping out */
        for (int y = 1; y < grid.height() - 2; y++) { //-2 for no perim channels
            /* perimeter has been precomputed */
            if (is_perimeter(grid, x, y)) {
                continue;
            }
            /* over each source side */
            for (e_side from_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                /* over each destination side */
                for (e_side to_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                    /* can't connect a side to itself */
                    if (from_side == to_side) {
                        continue;
                    }
                    /* over each source wire */
                    for (int iwire = 0; iwire < nodes_per_chan; iwire++) {
                        /* get the total x+y distance of the current switchblock from the reference switchblock */
                        int distance = (x - REF_X) + (y - REF_Y);
                        if (distance < 0) {
                            distance = sb_row_size - ((-1 * distance) % sb_row_size);
                        }
                        /* figure out the coordinates of the switchblock we want to copy */
                        int copy_y = 1;
                        int copy_x = 1 + (distance % sb_row_size); //TODO: based on what? explain staggering pattern

                        /* create the indices to key into the switchblock permutation map */
                        Switchblock_Lookup my_key(x, y, from_side, to_side, iwire);
                        Switchblock_Lookup copy_key(copy_x, copy_y, from_side, to_side, iwire);

                        if (sb_row->count(copy_key) == 0) {
                            continue;
                        }

                        (*sb_conns)[my_key] = sb_row->at(copy_key);
                    }
                }
            }
        }
    }
}

/* compute all the switchblocks around the perimeter of the FPGA for the given switchblock and wireconn */
static void compute_perimeter_switchblocks(t_chan_details* chan_details_x, t_chan_details* chan_details_y, vector<t_switchblock_inf>* switchblocks, const DeviceGrid& grid, int nodes_per_chan, t_wire_type_sizes* wire_type_sizes, e_directionality directionality, t_sb_connection_map* sb_conns) {
    int x, y;

    for (int isb = 0; isb < (int)switchblocks->size(); isb++) {
        /* along left and right edge */
        x = 0;
        t_switchblock_inf* sb = &(switchblocks->at(isb));
        for (int i = 0; i < 2; i++) { //TODO: can use i+=grid.width()-2 to make more explicit what the ranges of the loop are
            for (y = 0; y < grid.height(); y++) {
                if (sb_not_here(grid, x, y, sb->location)) {
                    continue;
                }
                /* now we iterate over all the potential side1->side2 connections */
                for (e_side from_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                    for (e_side to_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                        /* Fill appropriate entry of the sb_conns map with vector specifying the wires
                         * the current wire will connect to */
                        compute_wire_connections(x, y, from_side, to_side,
                                                 chan_details_x, chan_details_y, sb, grid,
                                                 wire_type_sizes, directionality, sb_conns);
                    }
                }
            }
            x = grid.width() - 2; //-2 for no perim channels
        }
    }

    for (int isb = 0; isb < (int)switchblocks->size(); isb++) {
        /* along bottom and top edge */
        y = 0;
        t_switchblock_inf* sb = &(switchblocks->at(isb));
        for (int i = 0; i < 2; i++) {
            for (x = 0; x < grid.width(); x++) {
                if (sb_not_here(grid, x, y, sb->location)) {
                    continue;
                }
                /* now we iterate over all the potential side1->side2 connections */
                for (e_side from_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                    for (e_side to_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                        /* Fill appropriate entry of the sb_conns map with vector specifying the wires
                         * the current wire will connect to */
                        compute_wire_connections(x, y, from_side, to_side,
                                                 chan_details_x, chan_details_y, sb, grid,
                                                 wire_type_sizes, directionality, sb_conns);
                    }
                }
            }
            y = grid.height() - 2; //-2 for no perim channels
        }
    }
}

#endif //FAST_SB_COMPUTATION

/* returns true if the coordinates x/y do not correspond to the location specified by 'location' */
static bool sb_not_here(const DeviceGrid& grid, int x, int y, e_sb_location location) {
    bool sb_not_here = true;

    switch (location) {
        case E_EVERYWHERE:
            sb_not_here = false;
            break;
        case E_PERIMETER:
            if (is_perimeter(grid, x, y)) {
                sb_not_here = false;
            }
            break;
        case E_CORNER:
            if (is_corner(grid, x, y)) {
                sb_not_here = false;
            }
            break;
        case E_CORE:
            if (is_core(grid, x, y)) {
                sb_not_here = false;
            }
            break;
        case E_FRINGE_LEFT:
            if (is_perimeter_left(grid, x, y) && !is_corner(grid, x, y)) {
                sb_not_here = false;
            }
            break;
        case E_FRINGE_RIGHT:
            if (is_perimeter_right(grid, x, y) && !is_corner(grid, x, y)) {
                sb_not_here = false;
            }
            break;
        case E_FRINGE_BOTTOM:
            if (is_perimeter_bottom(grid, x, y) && !is_corner(grid, x, y)) {
                sb_not_here = false;
            }
            break;
        case E_FRINGE_TOP:
            if (is_perimeter_top(grid, x, y) && !is_corner(grid, x, y)) {
                sb_not_here = false;
            }
            break;
        default:
            vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "sb_not_here: unrecognized location enum: %d\n", location);
            break;
    }
    return sb_not_here;
}

/* checks if the specified coordinates represent a corner of the FPGA */
static bool is_corner(const DeviceGrid& grid, int x, int y) {
    bool is_corner = false;
    if ((x == 0 && y == 0) || (x == 0 && y == int(grid.height()) - 2) || //-2 for no perim channels
        (x == int(grid.width()) - 2 && y == 0) ||                        //-2 for no perim channels
        (x == int(grid.width()) - 2 && y == int(grid.height()) - 2)) {   //-2 for no perim channels
        is_corner = true;
    }
    return is_corner;
}

/* checks if the specified coordinates correspond to one of the perimeter switchblocks */
static bool is_perimeter(const DeviceGrid& grid, int x, int y) {
    bool is_perimeter = false;
    if (x == 0 || x == int(grid.width()) - 2 || y == 0 || y == int(grid.height()) - 2) {
        is_perimeter = true;
    }
    return is_perimeter;
}

static bool is_perimeter_left(const DeviceGrid& grid, int x, int y) {
    bool is_perimeter_left = false;
    if (x == 0) {
        is_perimeter_left = true;
    }
    return is_perimeter_left;
}

static bool is_perimeter_right(const DeviceGrid& grid, int x, int y) {
    bool is_perimeter_right = false;
    if (x == int(grid.width()) - 2) {
        is_perimeter_right = true;
    }
    return is_perimeter_right;
}

static bool is_perimeter_top(const DeviceGrid& grid, int x, int y) {
    bool is_perimeter_top = false;
    if (y == int(grid.height()) - 2) {
        is_perimeter_top = true;
    }
    return is_perimeter_top;
}

static bool is_perimeter_bottom(const DeviceGrid& grid, int x, int y) {
    bool is_perimeter_bottom = false;
    if (y == 0) {
        is_perimeter_bottom = true;
    }
    return is_perimeter_bottom;
}

/* checks if the specified coordinates correspond to the core of the FPGA (i.e. not perimeter) */
static bool is_core(const DeviceGrid& grid, int x, int y) {
    bool is_core = !is_perimeter(grid, x, y);
    return is_core;
}

/* Counts the number of wires in each wire type in the specified channel */
void count_wire_type_sizes(const t_chan_seg_details* channel, int nodes_per_chan, t_wire_type_sizes* wire_type_sizes) {
    string wire_type;
    string new_type;
    int new_length, length;
    int new_start, start;
    int num_wires = 0;
    Wire_Info wire_info;

    auto& device_ctx = g_vpr_ctx.device();
    auto const& segment_inf = device_ctx.arch->Segments;

    wire_type = channel[0].type_name();
    length = channel[0].length();
    start = 0;
    for (int iwire = 0; iwire < nodes_per_chan; iwire++) {
        new_type = channel[iwire].type_name();
        new_length = segment_inf[channel[iwire].index()].length;//for bend wire the length of track maybe not its real length
        new_start = iwire;
        if (new_type != wire_type) {
            wire_info.set(length, num_wires, start);
            (*wire_type_sizes)[wire_type] = wire_info;
            wire_type = new_type;
            length = new_length;
            start = new_start;
            num_wires = 0;
        }
        num_wires++;
    }
    wire_info.set(length, num_wires, start);
    (*wire_type_sizes)[wire_type] = wire_info;

    return;
}

/* returns the wire indices belonging to the types in 'wire_type_vec' and switchpoints in 'points' at the given channel segment */
static std::vector<t_wire_switchpoint> get_switchpoint_wires(const DeviceGrid& grid, const t_chan_seg_details* chan_details, t_rr_type chan_type, int x, int y, e_side side, const vector<t_wire_switchpoints>& wire_switchpoints_vec, t_wire_type_sizes* wire_type_sizes, bool is_dest, SwitchPointOrder switchpoint_order, vtr::RandState& rand_state) {
    std::vector<t_wire_switchpoint> all_collected_wire_switchpoints;

    int seg_coord = x;
    if (chan_type == CHANY) {
        seg_coord = y;
    }

    for (const t_wire_switchpoints& wire_switchpoints : wire_switchpoints_vec) {
        std::vector<t_wire_switchpoint> collected_wire_switchpoints;

        const auto& wire_type = wire_switchpoints.segment_name;
        const auto& points = wire_switchpoints.switchpoints;

        if ((*wire_type_sizes).find(wire_type) == (*wire_type_sizes).end()) {
            // wire_type_sizes may not contain wire_type if its seg freq is 0
            continue;
        }
        /* get the number of wires of given type */
        int num_type_wires = wire_type_sizes->at(wire_type).num_wires;
        /* get the last wire belonging to this type */
        int first_type_wire = wire_type_sizes->at(wire_type).start;
        int last_type_wire = first_type_wire + num_type_wires - 1;

        /* Walk through each wire segment of specified type and check whether it matches one
         * of the specified switchpoints.
         *
         * Note that we walk through the points in order, this ensures that returned switchpoints
         * match the order specified in the architecture, which we assume is a priority order specified
         * by the archtitect.
         */
        for (int valid_switchpoint : points) {
            for (int iwire = first_type_wire; iwire <= last_type_wire; iwire++) {
                e_direction seg_direction = chan_details[iwire].direction();

                /* unidirectional wires going in the decreasing direction can have an outgoing edge
                 * only from the top or right switch block sides, and an incoming edge only if they are
                 * at the left or bottom sides (analogous for wires going in INC direction) */
                if (side == TOP || side == RIGHT) {
                    if (seg_direction == DEC_DIRECTION && is_dest) {
                        continue;
                    }
                    if (seg_direction == INC_DIRECTION && !is_dest) {
                        continue;
                    }
                } else {
                    VTR_ASSERT(side == LEFT || side == BOTTOM);
                    if (seg_direction == DEC_DIRECTION && !is_dest) {
                        continue;
                    }
                    if (seg_direction == INC_DIRECTION && is_dest) {
                        continue;
                    }
                }

                int wire_switchpoint = get_switchpoint_of_wire(grid, chan_type, chan_details[iwire], seg_coord, side);

                /* check if this wire belongs to one of the specified switchpoints; add it to our 'wires' vector if so */
                if (wire_switchpoint != valid_switchpoint) continue;

                collected_wire_switchpoints.push_back({iwire, wire_switchpoint});
            }
        }

        all_collected_wire_switchpoints.insert(all_collected_wire_switchpoints.end(),
                                               collected_wire_switchpoints.begin(), collected_wire_switchpoints.end());
    }

    if (switchpoint_order == SwitchPointOrder::SHUFFLED) {
        //We new re-order the switchpoints to try to make adjacent switchpoints have different values

        vtr::shuffle(all_collected_wire_switchpoints.begin(), all_collected_wire_switchpoints.end(), rand_state);
    } else {
        VTR_ASSERT(switchpoint_order == SwitchPointOrder::FIXED);
        //Already ordered so same switchpoints are adjacent by above collection loop
    }

    return all_collected_wire_switchpoints;
}

/* Compute the wire(s) that the wire at (x, y, from_side, to_side) should connect to.
 * sb_conns is updated with the result */
static void compute_wire_connections(int x_coord, int y_coord, enum e_side from_side, enum e_side to_side, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, t_switchblock_inf* sb, const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, e_directionality directionality, t_sb_connection_map* sb_conns, vtr::RandState& rand_state) {
    int from_x, from_y;                     /* index into source channel */
    int to_x, to_y;                         /* index into destination channel */
    t_rr_type from_chan_type, to_chan_type; /* the type of channel - i.e. CHANX or CHANY */
    from_x = from_y = to_x = to_y = UNDEFINED;

    SB_Side_Connection side_conn(from_side, to_side);                 /* for indexing into this switchblock's permutation funcs */
    Switchblock_Lookup sb_conn(x_coord, y_coord, from_side, to_side); /* for indexing into FPGA's switchblock map */

    /* can't connect a switchblock side to itself */
    if (from_side == to_side) {
        return;
    }
    /* check that the permutation map has an entry for this side combination */
    if (sb->permutation_map.count(side_conn) == 0) {
        /* the specified switchblock does not have any permutation funcs for this side1->side2 connection */
        return;
    }

    /* find the correct channel, and the coordinates to index into it for both the source and
     * destination channels. also return the channel type (ie chanx/chany) into which we are
     * indexing */
    /* details for source channel */
    const t_chan_details& from_chan_details = index_into_correct_chan(x_coord, y_coord, from_side, chan_details_x, chan_details_y,
                                                                      &from_x, &from_y, &from_chan_type);

    /* details for destination channel */
    const t_chan_details& to_chan_details = index_into_correct_chan(x_coord, y_coord, to_side, chan_details_x, chan_details_y,
                                                                    &to_x, &to_y, &to_chan_type);

    /* make sure from_x/y and to_x/y aren't out of bounds */
    if (coords_out_of_bounds(grid, to_x, to_y, to_chan_type) || coords_out_of_bounds(grid, from_x, from_y, from_chan_type)) {
        return;
    }

    /* iterate over all the wire connections specified for this switch block */
    for (int iconn = 0; iconn < (int)sb->wireconns.size(); iconn++) {
        /* pointer to a connection specification between wire types/subsegment_nums */
        t_wireconn_inf* wireconn_ptr = &sb->wireconns[iconn];

        /* compute the destination wire segments to which the source wire segment should connect based on the
         * current wireconn */
        compute_wireconn_connections(grid, directionality, from_chan_details, to_chan_details,
                                     sb_conn, from_x, from_y, to_x, to_y, from_chan_type, to_chan_type, wire_type_sizes,
                                     sb, wireconn_ptr, sb_conns, rand_state);
    }

    return;
}

/* computes the destination wire segments that a source wire segment at the coordinate 'sb_conn' (in
 * channel segment with coordinate from_x/from_y) should connect to based on the specified 'wireconn_ptr'.
 * wireconn_ptr defines the source and destination sets of wire segments (based on wire segment type & switchpoint
 * as defined at the top of this file), and the indices of wires to connect to are relative to these sets */
static void compute_wireconn_connections(const DeviceGrid& grid, e_directionality directionality, const t_chan_details& from_chan_details, const t_chan_details& to_chan_details, Switchblock_Lookup sb_conn, int from_x, int from_y, int to_x, int to_y, t_rr_type from_chan_type, t_rr_type to_chan_type, t_wire_type_sizes* wire_type_sizes, t_switchblock_inf* sb, t_wireconn_inf* wireconn_ptr, t_sb_connection_map* sb_conns, vtr::RandState& rand_state) {
    constexpr bool verbose = false;

    /* vectors that will contain indices of the wires belonging to the source/dest wire types/points */

    std::vector<t_wire_switchpoint> potential_src_wires = get_switchpoint_wires(grid, from_chan_details[from_x][from_y].data(), from_chan_type, from_x, from_y, sb_conn.from_side,
                                                                                wireconn_ptr->from_switchpoint_set, wire_type_sizes, false, wireconn_ptr->from_switchpoint_order, rand_state);

    std::vector<t_wire_switchpoint> potential_dest_wires = get_switchpoint_wires(grid, to_chan_details[to_x][to_y].data(), to_chan_type, to_x, to_y, sb_conn.to_side,
                                                                                 wireconn_ptr->to_switchpoint_set, wire_type_sizes, true, wireconn_ptr->to_switchpoint_order, rand_state);

    VTR_LOGV(verbose, "SB_LOC: %d,%d %s->%s\n", sb_conn.x_coord, sb_conn.y_coord, SIDE_STRING[sb_conn.from_side], SIDE_STRING[sb_conn.to_side]);

    //Define to print out specific wire-switchpoints used in to/from sets, if verbose is set true
#if 0
    for (auto from_set : wireconn_ptr->from_switchpoint_set) {
        VTR_LOGV(verbose, "  FROM_SET: %s @", from_set.segment_name.c_str());
        for (int switchpoint : from_set.switchpoints) {
            VTR_LOGV(verbose, "%d ", switchpoint);
        }
    }
    VTR_LOGV(verbose, "\n");

    for (auto to_set : wireconn_ptr->to_switchpoint_set) {
        VTR_LOGV(verbose, "  TO_SET: %s @", to_set.segment_name.c_str());
        for (int switchpoint : to_set.switchpoints) {
            VTR_LOGV(verbose, "%d ", switchpoint);
        }
    }
    VTR_LOGV(verbose, "\n");

    vector<std::string> src_wire_str;
    for (t_wire_switchpoint wire_switchpoint : potential_src_wires) {
        src_wire_str.push_back(std::to_string(wire_switchpoint.wire) + "@" + std::to_string(wire_switchpoint.switchpoint));
    }
    vector<std::string> dst_wire_str;
    for (t_wire_switchpoint wire_switchpoint : potential_dest_wires) {
        dst_wire_str.push_back(std::to_string(wire_switchpoint.wire) + "@" + std::to_string(wire_switchpoint.switchpoint));
    }
    auto src_str = vtr::join(src_wire_str, ", ");
    auto dst_str = vtr::join(dst_wire_str, ", ");
    VTR_LOGV(verbose, "  SRC_WIRES: %s\n", src_str.c_str());
    VTR_LOGV(verbose, "  DST_WIRES: %s\n", dst_str.c_str());
#endif

    if (potential_src_wires.size() == 0 || potential_dest_wires.size() == 0) {
        //Can't make any connections between empty sets
        return;
    }

    /* At this point the vectors 'potential_src_wires' and 'potential_dest_wires' contain the indices of the from_type/from_point
     * and to_type/to_point wire segments. Now we compute the connections between them, according to permutation functions */
    size_t src_W = potential_src_wires.size();
    size_t dest_W = potential_dest_wires.size();

    //TODO: We could add another user-configurable parameter to control ordering of types in the sets.
    //      Currently we just iterate through them in order, but we could:
    //      * randomly shuffle, or
    //      * interleave (to ensure good diversity)

    //Determine how many connections to make
    size_t num_conns = evaluate_num_conns_formula(wireconn_ptr->num_conns_formula, potential_src_wires.size(), potential_dest_wires.size());

    VTR_LOGV(verbose, "  num_conns: %zu\n", num_conns);

    for (size_t iconn = 0; iconn < num_conns; ++iconn) {
        //Select the from wire
        // We modulo by the src set size to wrap around if there are more connections that src wires
        int src_wire_ind = iconn % potential_src_wires.size();  //Index in src set
        int from_wire = potential_src_wires[src_wire_ind].wire; //Index in channel

        e_direction from_wire_direction = from_chan_details[from_x][from_y][from_wire].direction();
        if (from_wire_direction == INC_DIRECTION) {
            /* if this is a unidirectional wire headed in the increasing direction (relative to coordinate system)
             * then switch block source side should be BOTTOM or LEFT */
            if (sb_conn.from_side == TOP || sb_conn.from_side == RIGHT) {
                continue;
            }
            VTR_ASSERT(sb_conn.from_side == BOTTOM || sb_conn.from_side == LEFT);
        } else if (from_wire_direction == DEC_DIRECTION) {
            /* a wire heading in the decreasing direction can only connect from the TOP or RIGHT sides of a switch block */
            if (sb_conn.from_side == BOTTOM || sb_conn.from_side == LEFT) {
                continue;
            }
            VTR_ASSERT(sb_conn.from_side == TOP || sb_conn.from_side == RIGHT);
        } else {
            VTR_ASSERT(from_wire_direction == BI_DIRECTION);
        }

        //Evaluate permutation functions for the from_wire
        SB_Side_Connection side_conn(sb_conn.from_side, sb_conn.to_side);
        vector<string>& permutations_ref = sb->permutation_map[side_conn];
        for (int iperm = 0; iperm < (int)permutations_ref.size(); iperm++) {
            /* Convert the symbolic permutation formula to a number */
            t_formula_data formula_data;
            formula_data.set_var_value("W", dest_W);
            formula_data.set_var_value("t", src_wire_ind);
            int raw_dest_wire_ind = get_sb_formula_raw_result(permutations_ref[iperm].c_str(), formula_data);
            int dest_wire_ind = adjust_formula_result(raw_dest_wire_ind, src_W, dest_W, iconn);

            if (dest_wire_ind < 0) {
                vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "Got a negative wire from switch block formula %s", permutations_ref[iperm].c_str());
            }

            int to_wire = potential_dest_wires[dest_wire_ind].wire; //Index in channel

            /* create the struct containing information about the target wire segment which will be added to the
             * sb connections map */
            t_switchblock_edge sb_edge;
            sb_edge.from_wire = from_wire;
            sb_edge.to_wire = to_wire;
            sb_edge.switch_ind = to_chan_details[to_x][to_y][to_wire].arch_wire_switch();
            VTR_LOGV(verbose, "  make_conn: %d -> %d switch=%d\n", sb_edge.from_wire, sb_edge.to_wire, sb_edge.switch_ind);

            /* and now, finally, add this switchblock connection to the switchblock connections map */
            (*sb_conns)[sb_conn].push_back(sb_edge);

            /* If bidir architecture, implement the reverse connection as well */
            if (BI_DIRECTIONAL == directionality) {
                t_switchblock_edge sb_reverse_edge = sb_edge;
                std::swap(sb_reverse_edge.from_wire, sb_reverse_edge.to_wire);
                //Since we are implementing the reverse connection we have swapped from and to.
                //
                //Coverity flags this (false positive), so annotatate so coverity ignores it:
                // coverity[swapped_arguments : Intentional]
                Switchblock_Lookup sb_conn_reverse(sb_conn.x_coord, sb_conn.y_coord, sb_conn.to_side, sb_conn.from_side);
                (*sb_conns)[sb_conn_reverse].push_back(sb_reverse_edge);
            }
        }
    }
}

static int evaluate_num_conns_formula(std::string num_conns_formula, int from_wire_count, int to_wire_count) {
    t_formula_data vars;

    vars.set_var_value("from", from_wire_count);
    vars.set_var_value("to", to_wire_count);

    return parse_formula(num_conns_formula, vars);
}

/* Here we find the correct channel (x or y), and the coordinates to index into it based on the
 * specified tile coordinates and the switchblock side. Also returns the type of channel
 * that we are indexing into (ie, CHANX or CHANY */
const t_chan_details& index_into_correct_chan(int tile_x, int tile_y, enum e_side side, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, int* set_x, int* set_y, t_rr_type* chan_type) {
    *chan_type = CHANX;

    /* here we use the VPR convention that a tile 'owns' the channels directly to the right
     * and above it */
    switch (side) {
        case TOP:
            /* this is y-channel belonging to tile above */
            *set_x = tile_x;
            *set_y = tile_y + 1;
            *chan_type = CHANY;
            return chan_details_y;
            break;
        case RIGHT:
            /* this is x-channel belonging to tile to the right */
            *set_x = tile_x + 1;
            *set_y = tile_y;
            *chan_type = CHANX;
            return chan_details_x;
            break;
        case BOTTOM:
            /* this is y-channel on the right of the tile */
            *set_x = tile_x;
            *set_y = tile_y;
            *chan_type = CHANY;
            return chan_details_y;
            break;
        case LEFT:
            /* this is x-channel on top of the tile */
            *set_x = tile_x;
            *set_y = tile_y;
            *chan_type = CHANX;
            return chan_details_x;
            break;
        default:
            vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "index_into_correct_chan: unknown side specified: %d\n", side);
            break;
    }
    VTR_ASSERT(false);
    return chan_details_x; //Unreachable
}

/* checks whether the specified coordinates are out of bounds */
bool coords_out_of_bounds(const DeviceGrid& grid, int x_coord, int y_coord, e_rr_type chan_type) {
    bool result = true;

    if (CHANX == chan_type) {
        if (x_coord <= 0 || x_coord >= int(grid.width()) - 1 || /* there is no x-channel at x=0 */
            y_coord < 0 || y_coord >= int(grid.height()) - 1) {
            result = true;
        } else {
            result = false;
        }
    } else if (CHANY == chan_type) {
        if (x_coord < 0 || x_coord >= int(grid.width()) - 1 || y_coord <= 0 || y_coord >= int(grid.height()) - 1) { /* there is no y-channel at y=0 */
            result = true;
        } else {
            result = false;
        }

    } else {
        vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "coords_out_of_bounds(): illegal channel type %d\n", chan_type);
    }
    return result;
}

/* returns the subsegment number of the specified wire at seg_coord */
static int get_wire_subsegment_num(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details& wire_details, int seg_coord) {
    /* We get wire subsegment number by comparing the wire's seg_coord to the seg_start of the wire.
     * The offset between seg_start (or seg_end) and seg_coord is the subsegment number
     *
     * Cases:
     * seg starts at bottom but does not extend all the way to the top -- look at seg_end
     * seg starts > bottom and does not extend all the way to top -- look at seg_start
     * seg starts > bottom but terminates all the way at the top -- look at seg_start
     * seg starts at bottom and extends all the way to the top -- look at seg end
     */

    int subsegment_num;
    int seg_start = wire_details.seg_start();
    int seg_end = wire_details.seg_end();
    e_direction direction = wire_details.direction();
    int wire_length = get_wire_segment_length(grid, chan_type, wire_details);
    int min_seg;

    /* determine the minimum and maximum values that the 'seg' coordinate
     * of a wire can take */
    min_seg = 1;

    if (seg_start != min_seg) {
        subsegment_num = seg_coord - seg_start;
    } else {
        subsegment_num = (wire_length - 1) - (seg_end - seg_coord);
    }

    /* if this wire is going in the decreasing direction, reverse the subsegment num */
    VTR_ASSERT(seg_end >= seg_start);
    if (direction == DEC_DIRECTION) {
        subsegment_num = wire_length - 1 - subsegment_num;
    }

    return subsegment_num;
}

/* returns wire segment length based on either:
 * 1) the wire length specified in the segment details variable for this wire (if this wire segment doesn't span entire FPGA)
 * 2) the seg_start and seg_end coordinates in the segment details for this wire (if this wire segment spans entire FPGA, as might happen for very long wires)
 *
 * Computing the wire segment length in this way help to classify short vs long wire segments according to switchpoint. */
int get_wire_segment_length(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details& wire_details) {
    int wire_length;

    int min_seg = 1;
    int max_seg = grid.width() - 2; //-2 for no perim channels
    if (chan_type == CHANY) {
        max_seg = grid.height() - 2; //-2 for no perim channels
    }

    int seg_start = wire_details.seg_start();
    int seg_end = wire_details.seg_end();

    if (seg_start == min_seg && seg_end == max_seg) {
        wire_length = seg_end - seg_start + 1;
    } else {
        wire_length = wire_details.length();
    }

    return wire_length;
}

/* Returns the switchpoint of the wire specified by wire_details at a segment coordinate
 * of seg_coord, and connection to the sb_side of the switchblock */
static int get_switchpoint_of_wire(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details& wire_details, int seg_coord, e_side sb_side) {
    /* this function calculates the switchpoint of a given wire by first calculating
     * the subsegmennt number of the specified wire. For instance, for a wire with L=4:
     *
     * switchpoint:	0-------1-------2-------3-------0
     * subsegment_num:	    0       1       2       3
     *
     * So knowing the wire's subsegment_num and which switchblock side it connects to is
     * enough to calculate the switchpoint
     *
     */

    int switchpoint;

    /* get the minimum and maximum segment coordinate which a wire in this channel type can take */
    int min_seg = 1;
    int max_seg = grid.width() - 2; //-2 for no perim channels
    if (chan_type == CHANY) {
        max_seg = grid.height() - 2; //-2 for no perim channels
    }

    /* check whether the current seg_coord/sb_side coordinate specifies a perimeter switch block side at which all wire segments terminate/start.
     * in this case only segments with switchpoints = 0 can exist */
    bool perimeter_connection = false;
    if ((seg_coord == min_seg && (sb_side == RIGHT || sb_side == TOP)) || (seg_coord == max_seg && (sb_side == LEFT || sb_side == BOTTOM))) {
        perimeter_connection = true;
    }

    if (perimeter_connection) {
        switchpoint = 0;
    } else {
        int wire_length = get_wire_segment_length(grid, chan_type, wire_details);
        int subsegment_num = get_wire_subsegment_num(grid, chan_type, wire_details, seg_coord);

        e_direction direction = wire_details.direction();
        if (LEFT == sb_side || BOTTOM == sb_side) {
            switchpoint = (subsegment_num + 1) % wire_length;
            if (direction == DEC_DIRECTION) {
                switchpoint = subsegment_num;
            }
        } else {
            VTR_ASSERT(RIGHT == sb_side || TOP == sb_side);
            switchpoint = subsegment_num;
            if (direction == DEC_DIRECTION) {
                switchpoint = (subsegment_num + 1) % wire_length;
            }
        }
    }

    return switchpoint;
}

/* adjusts the destination wire calculated from a permutation formula to account for negative indicies,
 * source wire set offset, and modulo by destination wire set size
 * */
static int adjust_formula_result(int dest_wire, int src_W, int dest_W, int connection_ind) {
    int result = dest_wire;

    if (dest_wire < 0) {
        //Adjust for negative indicies
        int mult = (-1 * dest_wire) / dest_W + 1;
        result = dest_wire + mult * dest_W;
    }

    //Offset the destination track by a multiple of src_W to ensure all destination tracks are covered
    //
    // The permutation formula produce a 1-to-1 mapping from src track to dest track (i.e. each source
    // track is mapped to precisely one destination track). This is problematic if we are processing
    // a wireconn which goes through the source set multiple times (e.g. dest set larger than src set while
    // processing a WireConnType::TO), since the permutation formula will only generate src_W track indicies
    // (leaving some of the destination tracks unconnected). To ensure we get different destination tracks on
    // subsequent passes through the same source set, we offset the raw track by a multiple of src_W. Note the
    // use of integer division; src_mult will equal 0 on the first pass, 1 on the second etc.
    int src_mult = connection_ind / src_W;
    result += src_W * src_mult;

    //Final result must be modulo dest_W
    result = (result + dest_W) % dest_W;

    return result;
}

/* Returns the switchpoint of the wire specified by wire_details at a segment coordinate
 * of seg_coord, and connection to the sb_side of the switchblock */
static int get_wire_subsegment_num_gsb(const t_chan_seg_details& wire_details, int seg_coord) {
    /* We get wire subsegment number by comparing the wire's seg_coord to the seg_start of the wire.
     * The offset between seg_start (or seg_end) and seg_coord is the subsegment number
     *
     * Cases:
     * seg starts at bottom but does not extend all the way to the top -- look at seg_end
     * seg starts > bottom and does not extend all the way to top -- look at seg_start
     * seg starts > bottom but terminates all the way at the top -- look at seg_start
     * seg starts at bottom and extends all the way to the top -- look at seg end
     */
    auto& device_ctx = g_vpr_ctx.device();
    auto const& segment_inf = device_ctx.arch->Segments;

    int subsegment_num = 0;
    int seg_start = wire_details.seg_start();
    int seg_end = wire_details.seg_end();
    e_direction direction = wire_details.direction();
    int wire_length = wire_details.length();
    int min_seg;

    auto const& segment = segment_inf[wire_details.index()];
    wire_length = segment.isbend ? segment.part_len[wire_details.part_idx()] : wire_details.length();

    /* determine the minimum and maximum values that the 'seg' coordinate
        * of a wire can take */
    min_seg = 1;

    if (seg_start != min_seg) {
        subsegment_num = seg_coord - seg_start;
    } else {
        subsegment_num = (wire_length - 1) - (seg_end - seg_coord);
    }

    /* if this wire is going in the decreasing direction, reverse the subsegment num */
    VTR_ASSERT(seg_end >= seg_start);
    if (direction == DEC_DIRECTION) {
        subsegment_num = wire_length - 1 - subsegment_num;
    }


    if (segment.isbend) {
        int part_id = wire_details.part_idx();
        for (int i = 0; i < wire_details.part_idx(); i++){
            subsegment_num += segment.part_len[i];
        }
    }

    return subsegment_num;
}

static int get_switchpoint_of_wire_gsb(const DeviceGrid& grid, e_rr_type chan_type, const t_chan_seg_details& wire_details, int seg_coord, e_side sb_side) {
    /* this function calculates the switchpoint of a given wire by first calculating
     * the subsegmennt number of the specified wire. For instance, for a wire with L=4:
     *
     * switchpoint:	0-------1-------2-------3-------0
     * subsegment_num:	    0       1       2       3
     *
     * So knowing the wire's subsegment_num and which switchblock side it connects to is
     * enough to calculate the switchpoint
     *
     */
    auto& device_ctx = g_vpr_ctx.device();
    auto const& segment_inf = device_ctx.arch->Segments;

    int switchpoint;

    int wire_length = segment_inf[wire_details.index()].length;
    int subsegment_num = get_wire_subsegment_num_gsb(wire_details, seg_coord);

    e_direction direction = wire_details.direction();
    if (LEFT == sb_side || BOTTOM == sb_side) {
        switchpoint = (subsegment_num + 1) % wire_length;
        if (direction == DEC_DIRECTION) {
            switchpoint = subsegment_num;
        }
    } else {
        VTR_ASSERT(RIGHT == sb_side || TOP == sb_side);
        switchpoint = subsegment_num;
        if (direction == DEC_DIRECTION) {
            switchpoint = (subsegment_num + 1) % wire_length;
        }
    }

    return switchpoint;
}
//for gsb arch*******************************************
t_gsb_connection_map* alloc_and_load_gsb_permutations(const t_chan_details& chan_details_x,
                                                      const t_chan_details& chan_details_y,
                                                      const DeviceGrid& grid,
                                                      std::vector<t_gsb_inf> gsb_fs,
                                                      t_chan_width* nodes_per_chan,
                                                      t_gsb_multistage_mux_map* gsb_multistage_mux_map,
                                                      std::map<std::string, std::vector<std::map<int, int>>> other_pbpin_to_clbpin_map) {
    /* get a single number for channel width */
    int channel_width = nodes_per_chan->max;
    if (nodes_per_chan->max != nodes_per_chan->x_min || nodes_per_chan->max != nodes_per_chan->y_min) {
        vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "gsb currently support consistent channel widths only.");
    }

    /* sparse array that will contain switch block connections */
    t_gsb_connection_map* gsb_conns = new t_gsb_connection_map;

    /* We assume that x & y channels have the same ratios of wire types. i.e., looking at a single
     * channel is representative of all channels in the FPGA -- as of 3/9/2013 this is true in VPR */
    t_wire_type_sizes wire_type_sizes;
    count_wire_type_sizes(chan_details_x[0][0].data(), channel_width, &wire_type_sizes);

    /* iterate over all the gsb specified in the architecture */
    for (int i_gsb = 0; i_gsb < (int)gsb_fs.size(); i_gsb++) {
        t_gsb_inf gsb = gsb_fs[i_gsb];
        /* Iterate over the x,y coordinates spanning the FPGA. */
        for (size_t x_coord = 0; x_coord < grid.width(); x_coord++) {
            for (size_t y_coord = 0; y_coord < grid.height(); y_coord++) {
                t_type_ptr type = grid[x_coord][y_coord].type;
                bool is_gsb_arch =false;
                for(auto pb_name : gsb.pbtype_names){
                    if(0 == strcmp(type->name, pb_name.c_str())){
                        is_gsb_arch = true;
                        break;
                    }
                }
                
                if(is_gsb_arch){
                    /* now we iterate over all the potential side1->side2 connections */
                    VTR_LOGV(verbose, "***********************GSB from_type : segment *****************************\n");
                    e_from_type from_type = e_from_type::FT_SEGMENT;
                    compute_gsb_wire_connections_seg(x_coord, y_coord, from_type,
                                                    chan_details_x, chan_details_y, &gsb, grid,
                                                    &wire_type_sizes, gsb_conns);

                    VTR_LOGV(verbose, "***********************GSB from_type : omux *****************************\n");
                    from_type = e_from_type::FT_OMUX;
                    compute_gsb_wire_connections_omux(x_coord, y_coord, from_type,
                                                    chan_details_x, chan_details_y, &gsb, grid,
                                                    &wire_type_sizes, gsb_conns);

                    VTR_LOGV(verbose, "***********************GSB from_type : pb *****************************\n");
                    from_type = e_from_type::FT_PB;
                    compute_gsb_wire_connections_pb(x_coord, y_coord, from_type,
                                                    chan_details_x, chan_details_y, &gsb, grid,
                                                    &wire_type_sizes, gsb_conns);

                    VTR_LOGV(verbose, "***********************GSB multistage mux map compute *****************************\n");
                    compute_multistage_mux_map(x_coord, y_coord, chan_details_x, chan_details_y, &gsb, grid, &wire_type_sizes, gsb_multistage_mux_map, other_pbpin_to_clbpin_map);
                }  
            }
        }
    }

    return gsb_conns;
}

void free_gsb_permutations(t_gsb_connection_map * conns) {
    conns->clear();
    delete conns;
    conns = nullptr;
    /* the switch block unordered_map can get quite large and it doesn't seem like the program
     * is interested in releasing the memory back to the OS after the map is cleared.
     * calling malloc_trim forces the program to give unused heap space back to the OS.
     * this significantly reduces memory usage during the routing stage when running multiple
     * large benchmark circuits in parallel. */
    vtr::malloc_trim(0);
    return;
}

//pbnodepbpbpinindextilepbpin
static std::vector<int> get_from_node_for_multistage_mux(int x_coord, int y_coord,
                                                         const t_chan_details& chan_details_x, const t_chan_details& chan_details_y,
                                                         const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, std::vector<t_mux_same_from_inf> from_mux_inf,
                                                         t_gsb_inf* gsb, const std::map<std::string, std::vector<std::map<int, int>>> other_pbpin_to_clbpin_map){
    int from_x, from_y;                     /* index into source channel */
    t_rr_type from_chan_type; /* the type of channel - i.e. CHANX or CHANY */
    from_x = from_y = UNDEFINED;
    std::vector<int> medium_from_nodes;

    auto& device_ctx = g_vpr_ctx.device();

    bool is_other_tile = false;
    auto type = grid[x_coord][y_coord].type;
    std::string pbtype_name = type->name;
    auto iter = other_pbpin_to_clbpin_map.find(pbtype_name);
    if (iter != other_pbpin_to_clbpin_map.end()) {
        is_other_tile = true;
    }

    for (auto const& same_from : from_mux_inf) {
        if (same_from.mux_from_type == e_from_type::FT_SEGMENT) {
            t_wire_switchpoints from_switchpoints;
            from_switchpoints.segment_name = same_from.from_name;
            from_switchpoints.switchpoints = {0};

            for (int i = 0; i < same_from.from_inds.size(); i++) {
                e_side from_side = same_from.from_sides[i];
                const t_chan_details& from_chan_details = index_into_correct_chan(x_coord, y_coord, from_side, chan_details_x, chan_details_y,
                                                                                  &from_x, &from_y, &from_chan_type);
                if (coords_out_of_bounds(grid, from_x, from_y, from_chan_type))
                    continue;
                std::vector<t_wire_switchpoint> potential_src_wires = get_switchpoint_wires_gsb(grid, from_chan_details[from_x][from_y].data(), from_chan_type, from_x, from_y, from_side,
                                                                                                from_switchpoints, wire_type_sizes, false);
                if(potential_src_wires.size()==0)
                    continue;

                int from_wire = potential_src_wires[same_from.from_inds[i]].wire;
                int from_node = get_rr_node_index(device_ctx.rr_node_indices, from_x, from_y, from_chan_type, from_wire);
                if(from_node == OPEN)
                    VPR_THROW(VPR_ERROR_ROUTE, "find gsb multistage mux from_node OPEN in compute_multistage_mux_map, from_track = %d.\n", same_from.from_inds[i]);
                medium_from_nodes.push_back(from_node);
            }

        } else if (same_from.mux_from_type == e_from_type::FT_OMUX) {
            for (int j = 0; j < same_from.from_inds.size(); j++) {
                int omux_index = same_from.from_inds[j];
                int from_node = get_medium_rr_node_index(device_ctx.medium_rr_node_indices, x_coord, y_coord, 0, 0, omux_index); //0-IMUX, 1-OMUX, 2-GSB
                if(from_node == OPEN)
                    VPR_THROW(VPR_ERROR_ROUTE, "find gsb multistage mux from_node OPEN in compute_multistage_mux_map, from_omux = %d.\n", same_from.from_inds[j]);;
                medium_from_nodes.push_back(from_node);
            }
        } else if (same_from.mux_from_type == e_from_type::FT_PB) {
            for (int j = 0; j < same_from.from_inds.size(); j++) {
                std::string port_name = same_from.from_pin_types[j];
                auto clb_type = find_pb_type(gsb->pbtype_names[0]); //pb
                int port_index = find_port(port_name, clb_type->pb_type);
                VTR_ASSERT(clb_type->pb_type->ports[port_index].type == OUT_PORT);
                int port_pin_index = same_from.from_inds[j];
                int clb_pin_index;
                get_blk_pin_from_port_pin(clb_type->index, port_index, port_pin_index, &clb_pin_index);
                
                if (is_other_tile) {
                    int index = grid[x_coord][y_coord].width_offset * type->height + grid[x_coord][y_coord].height_offset;
                    auto const pbpin_to_clbpin_map_tile = (iter->second)[index];
                    auto iter2 = pbpin_to_clbpin_map_tile.find(clb_pin_index);
                    if (iter2 != pbpin_to_clbpin_map_tile.end()) {
                        clb_pin_index = iter2->second;
                    } else {
                        continue;
                    }
                }
                int from_node;
                for(auto side : SIDES){
                    from_node = get_rr_node_index(device_ctx.rr_node_indices, x_coord, y_coord, OPIN, clb_pin_index, side);
                    if(from_node != OPEN)
                        break;
                }
                if(from_node == OPEN)
                    VPR_THROW(VPR_ERROR_ROUTE, "find gsb multistage mux from_node OPEN in compute_multistage_mux_map, from_opin = %s:%d.\n", port_name.c_str(), port_pin_index);
                medium_from_nodes.push_back(from_node);
            }
        } else {
            vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "Error multistage in compute_multistage_mux_map\n");
        }
    }

    return medium_from_nodes;
}

static void compute_multistage_mux_map(int x_coord, int y_coord, 
                                        const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                                        t_gsb_inf* gsb, const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, 
                                        t_gsb_multistage_mux_map* gsb_multistage_mux_map, 
                                        const std::map<std::string, std::vector<std::map<int, int>>> other_pbpin_to_clbpin_map){
    int to_x, to_y;                         /* index into destination channel */
    t_rr_type to_chan_type; /* the type of channel - i.e. CHANX or CHANY */
    to_x = to_y = UNDEFINED;
    int medium_index = 0;

    t_multistage_mux_inf_gsbloc multistage_mux_inf_gsbloc;

    auto& device_ctx = g_vpr_ctx.device();

    auto const& gms = gsb->gsb_multistage_mux_inf;
    multistage_mux_inf_gsbloc.multistage_mux_map_infs.reserve(gms.size());

    int mmux_id = 0;
    for(auto const& gm : gms){
        t_multistage_mux_map_inf multistage_mux_map_inf;

        VTR_ASSERT(gm.to_seg_names.size() == gm.to_tracks.size());
        multistage_mux_map_inf.to_nodes.resize(gm.to_seg_names.size());
        multistage_mux_map_inf.to_switches.resize(gm.to_seg_names.size());
        //multistage_mux_map_inf.from_normal_muxes.resize(gm.to_seg_names.size());

        //find to_wire
        for (int i = 0; i < gm.to_seg_names.size(); i++){
            t_wire_switchpoints to_switchpoints;
            to_switchpoints.segment_name = gm.to_seg_names[i];
            to_switchpoints.switchpoints = {0};

            e_side to_side = gm.to_tracks[i].first;
            int to_track = gm.to_tracks[i].second;

            const t_chan_details& to_chan_details = index_into_correct_chan(x_coord, y_coord, to_side, chan_details_x, chan_details_y,
                                                                            &to_x, &to_y, &to_chan_type);
            if (coords_out_of_bounds(grid, to_x, to_y, to_chan_type))
                continue;
            std::vector<t_wire_switchpoint> potential_dest_wires = get_switchpoint_wires_gsb(grid, to_chan_details[to_x][to_y].data(), to_chan_type, to_x, to_y, to_side,
                                                                                             to_switchpoints, wire_type_sizes, true);
            VTR_ASSERT(to_track <= potential_dest_wires.size());
            if(potential_dest_wires.size()==0)
                continue;
            int to_wire = potential_dest_wires[to_track].wire;
            multistage_mux_map_inf.to_switches[i] = to_chan_details[to_x][to_y][to_wire].arch_wire_switch();
            
            int to_node = get_rr_node_index(device_ctx.rr_node_indices, to_x, to_y, to_chan_type, to_wire);
            if(to_node == OPEN){
                VPR_THROW(VPR_ERROR_ROUTE, "find gsb multistage mux to_node OPEN in compute_multistage_mux_map, to_track = %d.\n", to_track);
            }
            multistage_mux_map_inf.to_nodes[i] = to_node;
            
        }

        //for resue mux
        multistage_mux_map_inf.reuse_medium_node.to_index = gm.reuse_mux_inf[0].to_track_index;
        int medium_node = get_medium_rr_node_index(device_ctx.medium_rr_node_indices, x_coord, y_coord, 2, 0, medium_index); //0-IMUX, 1-OMUX, 2-GSB
        if(medium_node == OPEN){
            VPR_THROW(VPR_ERROR_ROUTE, "find gsb medium node OPEN in compute_multistage_mux_map.\n");
        }
        multistage_mux_map_inf.reuse_medium_node.medium_node = medium_node;
        medium_index++;
        multistage_mux_map_inf.reuse_medium_node.medium_from_nodes = get_from_node_for_multistage_mux(x_coord, y_coord, chan_details_x, chan_details_y,
                                                                                                                 grid, wire_type_sizes, gm.reuse_mux_inf, gsb, other_pbpin_to_clbpin_map);

        //for normal mux
        for(auto normal_mux : gm.normal_mux_infs){
            t_medium_node_inf normal_mux_node;
            normal_mux_node.to_index = normal_mux[0].to_track_index;
            medium_node = get_medium_rr_node_index(device_ctx.medium_rr_node_indices, x_coord, y_coord, 2, 0, medium_index); //0-IMUX, 1-OMUX, 2-GSB
            if(medium_node == OPEN){
                VPR_THROW(VPR_ERROR_ROUTE, "find gsb medium node OPEN in compute_multistage_mux_map.\n");
            }
            normal_mux_node.medium_node = medium_node;
            medium_index++;
            normal_mux_node.medium_from_nodes = get_from_node_for_multistage_mux(x_coord, y_coord, chan_details_x, chan_details_y,
                                                                                            grid, wire_type_sizes, normal_mux, gsb, other_pbpin_to_clbpin_map);
            multistage_mux_map_inf.from_normal_muxes.push_back(normal_mux_node);
        }

        multistage_mux_inf_gsbloc.multistage_mux_map_infs.push_back(multistage_mux_map_inf);
        

        //map
        for (int j = 0; j < multistage_mux_map_inf.to_nodes.size(); j++){
            int to_node = multistage_mux_map_inf.to_nodes[j];
            if(to_node == 0)
                continue;
            int id_of_multistage_mux_map_infs = mmux_id;
            std::vector<int> id_vec_of_medium_from_nodes;
            for (int k = 0; k < multistage_mux_map_inf.from_normal_muxes.size(); k++) {
                if(multistage_mux_map_inf.from_normal_muxes[k].to_index == j){
                    id_vec_of_medium_from_nodes.push_back(k);
                }
            }

            if (multistage_mux_inf_gsbloc.to_node_loc_map.find(to_node) != multistage_mux_inf_gsbloc.to_node_loc_map.end()){
                vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "duplicate to_wire found in compute_multistage_mux_map\n");
            }

            multistage_mux_inf_gsbloc.to_node_loc_map[to_node] = make_pair(id_of_multistage_mux_map_infs, id_vec_of_medium_from_nodes);
        }

        mmux_id++;
    }

    GSB_Lookup gsb_ms(x_coord, y_coord, e_from_type::NUM_FT_TYPES, NUM_SIDES, NUM_SIDES); /* for indexing into FPGA's switchblock map */
    (*gsb_multistage_mux_map)[gsb_ms] = multistage_mux_inf_gsbloc;
}

static void compute_gsb_wire_connections_seg(int x_coord, int y_coord, enum e_from_type from_type, 
                                                const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                                                t_gsb_inf* gsb, const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, 
                                                t_gsb_connection_map* gsb_conns) {
    int from_x, from_y;                     /* index into source channel */
    int to_x, to_y;                         /* index into destination channel */
    t_rr_type from_chan_type, to_chan_type; /* the type of channel - i.e. CHANX or CHANY */
    from_x = from_y = to_x = to_y = UNDEFINED;

    for (int ig = 0; ig < (int)gsb->gsb_group_inf.size(); ig++) {
        const t_gsb_group_inf* gsb_g = &gsb->gsb_group_inf[ig];
        for(auto const& name : gsb_g->seg_name){
            t_wire_switchpoints to_switchpoints;
            to_switchpoints.segment_name = name;
            to_switchpoints.switchpoints = {0};
            VTR_LOGV(verbose, "GROUP %d. to_seg_name=%s\n", ig, name.c_str());
            for (int ig_f = 0; ig_f < (int)gsb_g->gsb_from_inf.size(); ig_f++) {
                const t_gsb_from_inf* gsb_f = &gsb_g->gsb_from_inf[ig_f];
                if(gsb_f->from_type != from_type) continue;

                //
                //for gsb detail conns: {from_side, to_side} -> {from_index_in_potential_wires, to_index_in_potential_wires}
                std::unordered_map<GSB_Side, std::vector<GSB_detail_conn>, t_hash_GSB_side> detail_map;
                if(gsb_f->_gsb_detail_inf.size()>0){
                    detail_map = get_detail_index_for_gsb(gsb_f);
                }

                //
                if(gsb_f->_only_use_group){
                    for(int itg = 0; itg < gsb_f->_gsb_todir_group_inf.size(); itg++){
                        auto const& gp = gsb_f->_gsb_todir_group_inf[itg];
                        e_side to_side = todir2side(gp.to_dir);
                        std::vector<e_side> from_side_set;

                        if(gp.from_dir[0] == e_seg_dir::NUM_D_TYPES){
                            from_side_set = {TOP, RIGHT, BOTTOM, LEFT};
                        }
                        else{
                            for(auto const& fd : gp.from_dir){
                                from_side_set.push_back(fromdir2side(fd));
                            }
                        }
                        
                        for(e_side from_side : from_side_set){
                            //from_dirdetailside
                            if (from_side == to_side && gp.from_dir[0] == e_seg_dir::NUM_D_TYPES && detail_map[{from_side, to_side}].size() == 0) continue;

                            GSB_Lookup gsb_conn(x_coord, y_coord, from_type, from_side, to_side); /* for indexing into FPGA's switchblock map */
                        
                            /* details for source channel */
                            const t_chan_details& from_chan_details = index_into_correct_chan(x_coord, y_coord, from_side, chan_details_x, chan_details_y,
                                                                          &from_x, &from_y, &from_chan_type);
                            /* details for destination channel */
                            const t_chan_details& to_chan_details = index_into_correct_chan(x_coord, y_coord, to_side, chan_details_x, chan_details_y,
                                                                        &to_x, &to_y, &to_chan_type);
                            /* make sure from_x/y and to_x/y aren't out of bounds */
                            if (coords_out_of_bounds(grid, to_x, to_y, to_chan_type) || coords_out_of_bounds(grid, from_x, from_y, from_chan_type)) 
                                continue;

                            //destsegto_sideswitchpointwire  
                            std::vector<t_wire_switchpoint> potential_dest_wires = get_switchpoint_wires_gsb(grid, to_chan_details[to_x][to_y].data(), to_chan_type, to_x, to_y, gsb_conn.to_side,
                                                                                                 to_switchpoints, wire_type_sizes, true);
                            VTR_ASSERT(gsb_g->track_nums <= potential_dest_wires.size());
                            if(gsb_g->track_nums < potential_dest_wires.size()){
                                potential_dest_wires.resize(gsb_g->track_nums);
                            }

                            compute_gsb_from_connections_seg(grid, potential_dest_wires, from_chan_details, to_chan_details,
                                                                gsb_conn, from_x, from_y, to_x, to_y, from_chan_type, wire_type_sizes,
                                                                gsb_f, detail_map, gsb_conns, itg);
                        }
                    }
                }
                //
                else{
                    for (e_side from_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                        for (e_side to_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                            //detailside
                            if (from_side == to_side && detail_map[{from_side, to_side}].size() == 0) continue;

                            GSB_Lookup gsb_conn(x_coord, y_coord, from_type, from_side, to_side); /* for indexing into FPGA's switchblock map */

                            /* details for source channel */
                            const t_chan_details& from_chan_details = index_into_correct_chan(x_coord, y_coord, from_side, chan_details_x, chan_details_y,
                                                                          &from_x, &from_y, &from_chan_type);
                            /* details for destination channel */
                            const t_chan_details& to_chan_details = index_into_correct_chan(x_coord, y_coord, to_side, chan_details_x, chan_details_y,
                                                                        &to_x, &to_y, &to_chan_type);
                            /* make sure from_x/y and to_x/y aren't out of bounds */
                            if (coords_out_of_bounds(grid, to_x, to_y, to_chan_type) || coords_out_of_bounds(grid, from_x, from_y, from_chan_type)) 
                                continue;

                            //destsegto_sideswitchpointwire  
                            std::vector<t_wire_switchpoint> potential_dest_wires = get_switchpoint_wires_gsb(grid, to_chan_details[to_x][to_y].data(), to_chan_type, to_x, to_y, gsb_conn.to_side,
                                                                                                 to_switchpoints, wire_type_sizes, true);
                            VTR_ASSERT(gsb_g->track_nums <= potential_dest_wires.size());
                            if(gsb_g->track_nums < potential_dest_wires.size()){
                                potential_dest_wires.resize(gsb_g->track_nums);
                            }


                            compute_gsb_from_connections_seg(grid, potential_dest_wires, from_chan_details, to_chan_details,
                                                                gsb_conn, from_x, from_y, to_x, to_y, from_chan_type, wire_type_sizes,
                                                                gsb_f, detail_map, gsb_conns, 0);
                        }
                    }
                }
            }
        }
    }
    return;
}

static void compute_gsb_wire_connections_omux(int x_coord, int y_coord, enum e_from_type from_type, 
                                                const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                                                t_gsb_inf* gsb, const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, 
                                                t_gsb_connection_map* gsb_conns) {
    int to_x, to_y;                         /* index into destination channel */
    t_rr_type to_chan_type; /* the type of channel - i.e. CHANX or CHANY */
    to_x = to_y = UNDEFINED;

    for (int ig = 0; ig < (int)gsb->gsb_group_inf.size(); ig++) {
        const t_gsb_group_inf* gsb_g = &gsb->gsb_group_inf[ig];
        for(auto const& name : gsb_g->seg_name){
            t_wire_switchpoints to_switchpoints;
            to_switchpoints.segment_name = name;
            to_switchpoints.switchpoints = {0};
            VTR_LOGV(verbose, "GROUP %d. to_seg_name=%s\n", ig, name.c_str());

            for (int ig_f = 0; ig_f < (int)gsb_g->gsb_from_inf.size(); ig_f++) {
                const t_gsb_from_inf* gsb_f = &gsb_g->gsb_from_inf[ig_f];
                if(gsb_f->from_type != from_type) continue;

                //omuxdetail
                VTR_ASSERT(gsb_f->_only_detail == false);

                if(gsb_f->_only_use_group){
                    for(int itg = 0; itg < gsb_f->_gsb_todir_group_inf.size(); itg++){
                        auto const& gp = gsb_f->_gsb_todir_group_inf[itg];
                        e_side to_side = todir2side(gp.to_dir);
                        VTR_ASSERT(gp.from_dir[0] == e_seg_dir::NUM_D_TYPES);//omuxside

                        GSB_Lookup gsb_conn(x_coord, y_coord, from_type, e_side::NUM_SIDES, to_side); 
                        
                        /* details for destination channel */
                        const t_chan_details& to_chan_details = index_into_correct_chan(x_coord, y_coord, to_side, chan_details_x, chan_details_y,
                                                                        &to_x, &to_y, &to_chan_type);

                        /* make sure from_x/y and to_x/y aren't out of bounds */
                        if (coords_out_of_bounds(grid, to_x, to_y, to_chan_type)) 
                            continue;

                        //destsegto_sideswitchpointwire  
                        std::vector<t_wire_switchpoint> potential_dest_wires = get_switchpoint_wires_gsb(grid, to_chan_details[to_x][to_y].data(), to_chan_type, to_x, to_y, gsb_conn.to_side,
                                                                                                 to_switchpoints, wire_type_sizes, true);
                        VTR_ASSERT(gsb_g->track_nums <= potential_dest_wires.size());
                        if(gsb_g->track_nums < potential_dest_wires.size()){
                            potential_dest_wires.resize(gsb_g->track_nums);
                        }

                        compute_gsb_from_connections_omuxOrpb(grid, potential_dest_wires, to_chan_details,
                                                              gsb_conn, to_x, to_y,
                                                              gsb_f, gsb_conns, itg, {}, gsb->pbtype_names[0]);
                    }
                }
                else{
                    for (e_side to_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                        GSB_Lookup gsb_conn(x_coord, y_coord, from_type, e_side::NUM_SIDES, to_side); 
                            
                        /* details for destination channel */
                        const t_chan_details& to_chan_details = index_into_correct_chan(x_coord, y_coord, to_side, chan_details_x, chan_details_y,
                                                                                            &to_x, &to_y, &to_chan_type);
                        /* make sure from_x/y and to_x/y aren't out of bounds */
                        if (coords_out_of_bounds(grid, to_x, to_y, to_chan_type)) 
                            continue;

                        //destsegto_sideswitchpointwire  
                        std::vector<t_wire_switchpoint> potential_dest_wires = get_switchpoint_wires_gsb(grid, to_chan_details[to_x][to_y].data(), to_chan_type, to_x, to_y, gsb_conn.to_side,
                                                                                                 to_switchpoints, wire_type_sizes, true);
                        VTR_ASSERT(gsb_g->track_nums <= potential_dest_wires.size());
                        if(gsb_g->track_nums < potential_dest_wires.size()){
                            potential_dest_wires.resize(gsb_g->track_nums);
                        }

                        compute_gsb_from_connections_omuxOrpb(grid, potential_dest_wires, to_chan_details,
                                                              gsb_conn, to_x, to_y,
                                                              gsb_f, gsb_conns, 0, {}, gsb->pbtype_names[0]);
                    }
                }
            }
        }
    }
    return;
}

static void compute_gsb_wire_connections_pb(int x_coord, int y_coord, enum e_from_type from_type, 
                                                const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                                                t_gsb_inf* gsb, const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, 
                                                t_gsb_connection_map* gsb_conns) {
    int to_x, to_y;                         /* index into destination channel */
    t_rr_type to_chan_type; /* the type of channel - i.e. CHANX or CHANY */
    to_x = to_y = UNDEFINED;

    for (int ig = 0; ig < (int)gsb->gsb_group_inf.size(); ig++) {
        const t_gsb_group_inf* gsb_g = &gsb->gsb_group_inf[ig];
        for(auto const& name : gsb_g->seg_name){
            t_wire_switchpoints to_switchpoints;
            to_switchpoints.segment_name = name;
            to_switchpoints.switchpoints = {0};
            VTR_LOGV(verbose, "GROUP %d. to_seg_name=%s\n", ig, name.c_str());

            for (int ig_f = 0; ig_f < (int)gsb_g->gsb_from_inf.size(); ig_f++) {
                const t_gsb_from_inf* gsb_f = &gsb_g->gsb_from_inf[ig_f];
                if(gsb_f->from_type != from_type) continue;

                //
                //pbdetail
                //for gsb detail (pb): {NUM_SIDES, to_side} -> {clb_port_name, from_clb_pin_index, to_index_in_potential_wires}
                std::unordered_map<GSB_Side, std::vector<GSB_detail_conn_pb>, t_hash_GSB_side> detail_map;
                //pb_typepin
                auto clb_type = find_pb_type(gsb->pbtype_names[0]);

                if(gsb_f->_gsb_detail_inf.size()>0){
                    detail_map = get_detail_index_for_gsb_pb(gsb_f, clb_type);
                }

                if(gsb_f->_only_use_group){
                    for(int itg = 0; itg < gsb_f->_gsb_todir_group_inf.size(); itg++){
                        auto const& gp = gsb_f->_gsb_todir_group_inf[itg];
                        e_side to_side = todir2side(gp.to_dir);
                        VTR_ASSERT(gp.from_dir[0] == e_seg_dir::NUM_D_TYPES);//pbside

                        GSB_Lookup gsb_conn(x_coord, y_coord, from_type, e_side::NUM_SIDES, to_side); 
                        
                        /* details for destination channel */
                        const t_chan_details& to_chan_details = index_into_correct_chan(x_coord, y_coord, to_side, chan_details_x, chan_details_y,
                                                                        &to_x, &to_y, &to_chan_type);

                        /* make sure from_x/y and to_x/y aren't out of bounds */
                        if (coords_out_of_bounds(grid, to_x, to_y, to_chan_type)) 
                            continue;

                        //destsegto_sideswitchpointwire  
                        std::vector<t_wire_switchpoint> potential_dest_wires = get_switchpoint_wires_gsb(grid, to_chan_details[to_x][to_y].data(), to_chan_type, to_x, to_y, gsb_conn.to_side,
                                                                                                 to_switchpoints, wire_type_sizes, true);
                        VTR_ASSERT(gsb_g->track_nums <= potential_dest_wires.size());
                        if(gsb_g->track_nums < potential_dest_wires.size()){
                            potential_dest_wires.resize(gsb_g->track_nums);
                        }

                        compute_gsb_from_connections_omuxOrpb(grid, potential_dest_wires, to_chan_details,
                                                              gsb_conn, to_x, to_y,
                                                              gsb_f, gsb_conns, itg, detail_map, gsb->pbtype_names[0]);
                    }
                }
                else{
                    for (e_side to_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                        GSB_Lookup gsb_conn(x_coord, y_coord, from_type, e_side::NUM_SIDES, to_side); /* for indexing into FPGA's switchblock map */
                            
                        /* details for destination channel */
                        const t_chan_details& to_chan_details = index_into_correct_chan(x_coord, y_coord, to_side, chan_details_x, chan_details_y,
                                                                                            &to_x, &to_y, &to_chan_type);
                        /* make sure from_x/y and to_x/y aren't out of bounds */
                        if (coords_out_of_bounds(grid, to_x, to_y, to_chan_type)) 
                            continue;

                        //destsegto_sideswitchpointwire  
                        std::vector<t_wire_switchpoint> potential_dest_wires = get_switchpoint_wires_gsb(grid, to_chan_details[to_x][to_y].data(), to_chan_type, to_x, to_y, gsb_conn.to_side,
                                                                                                 to_switchpoints, wire_type_sizes, true);
                        VTR_ASSERT(gsb_g->track_nums <= potential_dest_wires.size());
                        if(gsb_g->track_nums < potential_dest_wires.size()){
                            potential_dest_wires.resize(gsb_g->track_nums);
                        }

                        compute_gsb_from_connections_omuxOrpb(grid, potential_dest_wires, to_chan_details,
                                                              gsb_conn, to_x, to_y,
                                                              gsb_f, gsb_conns, 0, detail_map, gsb->pbtype_names[0]);
                    }
                }
            }
        }
    }
    return;
}

e_side todir2side(e_seg_dir seg_dir){
    switch(seg_dir){
        case e_seg_dir::D_E:
            return RIGHT;
            break;
        case e_seg_dir::D_W:
            return LEFT;
            break;
        case e_seg_dir::D_S:
            return BOTTOM;
            break;
        case e_seg_dir::D_N:
            return TOP;
            break;
        case e_seg_dir::NUM_D_TYPES:
            return NUM_SIDES;
            break;
        default:
            vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "todir2side: unknown dir specified: %d\n", seg_dir);
            break; 
    }
}

e_side fromdir2side(e_seg_dir seg_dir){
    switch(seg_dir){
        case e_seg_dir::D_E:
            return LEFT;
            break;
        case e_seg_dir::D_W:
            return RIGHT;
            break;
        case e_seg_dir::D_S:
            return TOP;
            break;
        case e_seg_dir::D_N:
            return BOTTOM;
            break;
        default:
            vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "fromdir2side: unknown dir specified: %d\n", seg_dir);
            break;
    }
}

//[clbpin_ind, detail.to_input()]
//for gsb: {NUM_SIDES, to_side} -> {clb_port_name, from_clb_pin_index, to_index_in_potential_wires}
std::unordered_map<GSB_Side, std::vector<GSB_detail_conn_pb>, t_hash_GSB_side> get_detail_index_for_gsb_pb(const t_common_from_inf* gsb_from, const t_type_ptr clb_type){
    e_side to_side;
    int j, from_output, pin_index;
    std::string port_name;
    std::unordered_map<GSB_Side, std::vector<GSB_detail_conn_pb>, t_hash_GSB_side> detail_map;

    for(auto const& df : gsb_from->detail_inf()){
        to_side = todir2side(df.to_dir);
        for(auto fstr : df.from_detail){
            auto str_vec = vtr::split(fstr, ":");
            VTR_ASSERT(str_vec.size() == 2);
            port_name = str_vec[0];
            pin_index = vtr::atoi(str_vec[1]);

            auto pb_type = clb_type->pb_type;
            j = find_port(port_name, pb_type);
            get_blk_pin_from_port_pin(clb_type->index, j, pin_index, &from_output);

            GSB_Side gs_key = {NUM_SIDES, to_side};
            GSB_detail_conn_pb gdp;
            gdp.port_name = port_name;
            gdp.from_output = from_output;
            gdp.to_input = df.to_input;
            detail_map[gs_key].push_back(gdp);
        }
    }
    return detail_map;
}

//for gsb: {from_side, to_side} -> {from_index_in_potential_wires, to_index_in_potential}
std::unordered_map<GSB_Side, std::vector<GSB_detail_conn>, t_hash_GSB_side> get_detail_index_for_gsb(const t_common_from_inf* gsb_from){
    e_side from_side, to_side;
    int from_output;
    std::unordered_map<GSB_Side, std::vector<GSB_detail_conn>, t_hash_GSB_side> detail_map;

    for(auto const& df : gsb_from->detail_inf()){
        to_side = todir2side(df.to_dir);
        for(auto const& fstr : df.from_detail){
            //VTR_LOG("from_detail: %s", fstr.c_str());
            from_side = fromdir2side(string_to_segdir(fstr.substr(0,1)));
            from_output = vtr::atoi(fstr.substr(1, fstr.length()-1));
            GSB_Side gs_key = {from_side, to_side};
            detail_map[gs_key].push_back({from_output, df.to_input});
        }
    }
    return detail_map;
}

//get index for from-to indexto_index_in_potential_wires -> [from_index_in_potential_wires/omux_pin_index]([0..to_nums-1][0..num_foreach-1])
std::vector<std::vector<int>> get_from_index_for_gsb(const t_common_from_inf* gsb_from, int total_froms, int to_nums, int itg){
    int from_nums, from_group, to_group, sign;
    int from_start, offset, num_foreach;
    int actual_start = 0, actual_foreach = 0;
    std::vector<std::vector<int>> to_from_index;
    to_from_index.resize(to_nums);

    if(gsb_from->only_use_group()){
        auto const& gt = gsb_from->gsb_todir_group_inf()[itg];
        from_nums = gt.total_froms == 999 ? total_froms : gt.total_froms;
        from_group = gt.from_group;
        to_group = gt.to_group;
        sign = gt.pos_order ? 1 : -1;
        from_start = gt.from_start;
        offset = gt.offset;
        num_foreach = gt.num_foreach;
        actual_start = gt.actual_start;
        actual_foreach = gt.actuall_foreach;
    }
    else{
        from_nums = total_froms;
        from_group = gsb_from->from_group;
        to_group = gsb_from->to_group;
        sign = gsb_from->pos_order ? 1 : -1;
        from_start = gsb_from->from_start;
        offset = gsb_from->offset;
        num_foreach = gsb_from->num_foreach;
    }

    //from_index3 7 0 4 1 5 2 6
    std::vector<int> from_index;
    from_index.reserve(from_nums);
    /*if(from_nums % from_group != 0){
        int a;
        a++;
    }*/
    VTR_ASSERT(from_nums % from_group == 0);
    int from_group_size = from_nums / from_group;
    int f_i;
    for(int i = 0; i < from_group_size; i++){
        f_i = i * sign + offset;
        int mod_fi = f_i % from_group_size < 0 ? f_i % from_group_size + from_group_size : f_i % from_group_size;
        for(int g = 0; g < from_group; g++){
            from_index.push_back(mod_fi + g * from_group_size + from_start);
        }
    }
    
    //tonum_foreachfrom_index
    int t_i;
    int i_f = 0;
    if(gsb_from->to_fix_order().size() == 0){
        VTR_ASSERT(to_nums % to_group == 0);
        int to_group_size = to_nums / to_group;
        for(int i = 0; i < to_group_size; i++){
            for(int g = 0; g < to_group; g++){
                t_i = i + g * to_group_size;
                for(int nf = 0; nf < num_foreach; nf++){
                    to_from_index[t_i].push_back(from_index[(i_f++) % from_nums]);
                }
            }
        }
    }
    else{
        auto to_fix_order = gsb_from->to_fix_order();
        VTR_ASSERT(to_fix_order.size() == to_nums);
        for(int i = 0; i < to_nums; i++){
            t_i = to_fix_order[i];
            for(int nf = 0; nf < num_foreach; nf++){
                to_from_index[t_i].push_back(from_index[(i_f++) % from_nums]);
            }
        }
    }

    //actual
    if(actual_foreach != 0){
        VTR_ASSERT(actual_start + actual_foreach <= num_foreach);
        for(auto it = to_from_index.begin(); it != to_from_index.end(); it++){
            std::copy((*it).begin() + actual_start, (*it).begin() + actual_start + actual_foreach, (*it).begin());
            (*it).resize(actual_foreach);
        }
    }

    return to_from_index;
}

//get index for from-to indexto_index_in_potential_wires -> [clb_pin_index]([0..to_nums-1][0..num_foreach-1])
std::vector<std::vector<int>> get_from_index_for_gsb_pb(const t_common_from_inf* gsb_from, int total_froms, int to_nums, const t_type_ptr clb_type, int itg){
    int from_nums, from_group, to_group, sign;
    int from_start, offset, num_foreach;
    int actual_start, actual_foreach = 0;
    int overlap = 0;
    int j;
    std::vector<std::string> pin_types;
    std::vector<std::vector<int>> to_from_index;
    to_from_index.resize(to_nums);

    if(gsb_from->only_use_group()){
        auto const& gt = gsb_from->gsb_todir_group_inf()[itg];
        from_nums = gt.total_froms == 999 ? total_froms : gt.total_froms;
        from_group = gt.from_group;
        to_group = gt.to_group;
        sign = gt.pos_order ? 1 : -1;
        from_start = gt.from_start;
        offset = gt.offset;
        num_foreach = gt.num_foreach;
        actual_start = gt.actual_start;
        actual_foreach = gt.actuall_foreach;
        pin_types = gt.pin_types;
    }
    else{
        from_nums = total_froms;
        from_group = gsb_from->from_group;
        to_group = gsb_from->to_group;
        sign = gsb_from->pos_order ? 1 : -1;
        from_start = gsb_from->from_start;
        offset = gsb_from->offset;
        num_foreach = gsb_from->num_foreach;
        pin_types = gsb_from->pin_types;
        overlap = gsb_from->overlap();
    }

    auto pb_type = clb_type->pb_type;
    std::vector<std::vector<int>> clb_pin_index_according_pin_types;//[num_ports][clb_pin_index]
    int pin_index;
    clb_pin_index_according_pin_types.resize(pin_types.size());
    for(int k = 0; k < pin_types.size(); k++){
        auto port_name = pin_types[k];
        for (j = 0; j < pb_type->num_ports; j++) {
            if (strcmp(pb_type->ports[j].name, port_name.c_str()) == 0) {
                break;
            }
        }
        if (j >= pb_type->num_ports) {
            vpr_throw(VPR_ERROR_ARCH, get_arch_file_name(), 0, "get_from_index_for_gsb_pb : Unable to find port %s on plb.\n", port_name.c_str());
        }

        for(int i = 0; i < pb_type->ports[j].num_pins; i++){
            get_blk_pin_from_port_pin(clb_type->index, j, i, &pin_index);
            clb_pin_index_according_pin_types[k].push_back(pin_index);
        }
    }

    //portpinia,xa,ib,xb,...clb_pin_ind
    std::vector<int> clb_pin_index;
    //portpin
    for(int i = 0; i < clb_pin_index_according_pin_types[0].size(); i++){
        for(auto i_vec : clb_pin_index_according_pin_types){
            clb_pin_index.push_back(i_vec[i]);
        }
    }
    VTR_ASSERT(from_nums == clb_pin_index.size());

    //from_indexclb_pin_indexto_from_indexnum_foreach
    std::vector<int> from_index;
    from_index.reserve(from_nums);
    VTR_ASSERT(from_nums % from_group == 0);
    int from_group_size = from_nums / from_group;
    int f_i;
    for(int i = 0; i < from_group_size; i++){
        f_i = i * sign + offset;
        int mod_fi = f_i % from_group_size < 0 ? f_i % from_group_size + from_group_size : f_i % from_group_size;
        for(int g = 0; g < from_group; g++){
            from_index.push_back(clb_pin_index[mod_fi + g * from_group_size + from_start]);
        }
    }

    int t_i;
    int i_f = 0;
    if(gsb_from->to_fix_order().size() == 0) {
        VTR_ASSERT(to_nums % to_group == 0);
        int to_group_size = to_nums / to_group;
        for (int i = 0; i < to_group_size; i++) {
            for (int g = 0; g < to_group; g++) {
                t_i = i + g * to_group_size;
                for (int nf = 0; nf < num_foreach; nf++) {
                    to_from_index[t_i].push_back(from_index[(i_f++) % from_nums]);
                }
                i_f -= overlap;
            }
        }
    }
    else{
        auto to_fix_order = gsb_from->to_fix_order();
        VTR_ASSERT(to_fix_order.size() == to_nums);
        for(int i = 0; i < to_nums; i++){
            t_i = to_fix_order[i];
            for(int nf = 0; nf < num_foreach; nf++){
                to_from_index[t_i].push_back(from_index[(i_f++) % from_nums]);
            }
            i_f -= overlap;
        }
    }

    if(actual_foreach != 0){
        VTR_ASSERT(actual_start + actual_foreach <= num_foreach);
        for(auto it = to_from_index.begin(); it != to_from_index.end(); it++){
            std::copy((*it).begin() + actual_start, (*it).begin() + actual_start + actual_foreach, (*it).begin());
            (*it).resize(actual_foreach);
        }
    }

    return to_from_index;
}

/*
static const t_chan_details& index_into_correct_chan_gsb(int tile_x, int tile_y, enum e_seg_dir seg_dir, bool isFrom, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, int* set_x, int* set_y, t_rr_type* chan_type) {
    *chan_type = CHANX;

    switch (seg_dir) {
        case e_seg_dir::D_E:
            *set_x = isFrom ? tile_x : tile_x + 1;
            *set_y = tile_y;
            *chan_type = CHANX;
            return chan_details_x;
            break;
        case e_seg_dir::D_W:
            *set_x = isFrom ? tile_x + 1 : tile_x;
            *set_y = tile_y;
            *chan_type = CHANX;
            return chan_details_x;
            break;
        case e_seg_dir::D_S:
            *set_x = tile_x;
            *set_y = isFrom ? tile_y + 1 : tile_y;
            *chan_type = CHANY;
            return chan_details_y;
            break;
        case e_seg_dir::D_N:
            *set_x = tile_x;
            *set_y = isFrom ? tile_y : tile_y + 1;
            *chan_type = CHANY;
            return chan_details_y;
            break;
        default:
            vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "index_into_correct_chan: unknown dir specified: %d\n", seg_dir);
            break;
    }
    VTR_ASSERT(false);
    return chan_details_x; //Unreachable
}
*/

//gsbsegment
static void compute_gsb_from_connections_seg(const DeviceGrid& grid, std::vector<t_wire_switchpoint> potential_dest_wires,
                                                const t_chan_details& from_chan_details, const t_chan_details& to_chan_details,
                                                GSB_Lookup gsb_conn, int from_x, int from_y, int to_x, int to_y, t_rr_type from_chan_type, 
                                                t_wire_type_sizes* wire_type_sizes, const t_common_from_inf* gsb_from,
                                                std::unordered_map<GSB_Side, std::vector<GSB_detail_conn>, t_hash_GSB_side> detail_map, 
                                                t_gsb_connection_map* gsb_conns, int itg) {
    //constexpr bool verbose = true;
    for(auto const& name : gsb_from->from_name){
        t_wire_switchpoints from_switchpoints;
        from_switchpoints.segment_name = name;
        from_switchpoints.switchpoints = gsb_from->from_switchpoints;

        //srcfrom_sideswitchpointwire
        std::vector<t_wire_switchpoint> potential_src_wires = get_switchpoint_wires_gsb(grid, from_chan_details[from_x][from_y].data(), from_chan_type, from_x, from_y, gsb_conn.from_side,
                                                                                from_switchpoints, wire_type_sizes, false);

        VTR_LOGV(verbose, "GSB_LOC: %d,%d %s->%s\n", gsb_conn.x_coord, gsb_conn.y_coord, SIDE_STRING[gsb_conn.from_side], SIDE_STRING[gsb_conn.to_side]);
        VTR_LOGV(verbose, "from_type = segment. from_name =%s\n", name.c_str());
        //Define to print out specific wire-switchpoints used in to/from sets, if verbose is set true
        #if 0
            VTR_LOGV(verbose, "  FROM_SET: %s @", from_switchpoints.segment_name.c_str());
            for (int switchpoint : from_switchpoints.switchpoints) {
                VTR_LOGV(verbose, "%d ", switchpoint);
            }
            VTR_LOGV(verbose, "\n");

            VTR_LOGV(verbose, "  TO_SET: %s @", to_switchpoints.segment_name.c_str());
            for (int switchpoint : to_switchpoints.switchpoints) {
                VTR_LOGV(verbose, "%d ", switchpoint);
            }
            VTR_LOGV(verbose, "\n");

            vector<std::string> src_wire_str;
            for (t_wire_switchpoint wire_switchpoint : potential_src_wires) {
                src_wire_str.push_back(std::to_string(wire_switchpoint.wire) + "@" + std::to_string(wire_switchpoint.switchpoint));
            }
            vector<std::string> dst_wire_str;
            for (t_wire_switchpoint wire_switchpoint : potential_dest_wires) {
                dst_wire_str.push_back(std::to_string(wire_switchpoint.wire) + "@" + std::to_string(wire_switchpoint.switchpoint));
            }
            auto src_str = vtr::join(src_wire_str, ", ");
            auto dst_str = vtr::join(dst_wire_str, ", ");
            VTR_LOGV(verbose, "  SRC_WIRES: %s\n", src_str.c_str());
            VTR_LOGV(verbose, "  DST_WIRES: %s\n", dst_str.c_str());
        #endif

        if (potential_src_wires.size() == 0 || potential_dest_wires.size() == 0) 
            //Can't make any connections between empty sets
            return;

        /* At this point the vectors 'potential_src_wires' and 'potential_dest_wires' contain the indices of the from_type/from_point
         * and to_type/to_point wire segments. Now we compute the connections between them, according to permutation functions */
        size_t src_W = potential_src_wires.size();
        int total_froms;

        if (gsb_from->total_froms == 999){
            VTR_ASSERT(gsb_from->from_start == 0);
            total_froms = potential_src_wires.size();
        }
        else{                                                                           
            VTR_ASSERT(gsb_from->from_start + gsb_from->total_froms <= src_W);
            total_froms = gsb_from->total_froms;
        }

        //detail
        auto detail_vec = detail_map[{gsb_conn.from_side, gsb_conn.to_side}];
        VTR_LOGV(verbose, "num_to(detail): %zu\n", detail_vec.size());
        for(auto const& detail : detail_vec){
            int to_wire = potential_dest_wires[detail.to_input].wire;
            int from_wire = potential_src_wires[detail.from_output].wire;
            e_direction from_wire_direction = from_chan_details[from_x][from_y][from_wire].direction();
            if (from_wire_direction == INC_DIRECTION) {
                VTR_ASSERT(gsb_conn.from_side == BOTTOM || gsb_conn.from_side == LEFT);
            } else if (from_wire_direction == DEC_DIRECTION) {
                VTR_ASSERT(gsb_conn.from_side == TOP || gsb_conn.from_side == RIGHT);
            } else {
                vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "compute_gsb_from_connections_seg : Can't support bi-direction wire");
            }
            t_gsb_edge gsb_edge;
            gsb_edge.from_wireOrpin = from_wire;
            gsb_edge.to_wireOrpin = to_wire;
            gsb_edge.switch_ind = to_chan_details[to_x][to_y][to_wire].arch_wire_switch();
            VTR_LOGV(verbose, "    index_conn: %d -> %d\t", detail.from_output, detail.to_input);
            VTR_LOGV(verbose, "    make_conn: %d -> %d switch=%d\n", gsb_edge.from_wireOrpin, gsb_edge.to_wireOrpin, gsb_edge.switch_ind);
            (*gsb_conns)[gsb_conn].push_back(gsb_edge);
        }

        //detail
        //to_from_indexto_index_in_potential_wires -> [from_index_in_potential_wires]([0..to_nums-1][0..num_foreach-1])
        std::vector<std::vector<int>> to_from_index;
        if ( !gsb_from->only_detail() ){
            to_from_index = get_from_index_for_gsb(gsb_from, total_froms, potential_dest_wires.size(), itg);
        }
        else{
            continue;
        }

        //side
        if(gsb_conn.from_side == gsb_conn.to_side && !gsb_from->only_use_group()) continue;
        VTR_LOGV(verbose, "num_to: %zu\n", to_from_index.size());
        for(int to_i = 0; to_i < to_from_index.size(); to_i++){
            //VTR_LOGV(verbose, "  to_index: %zu\n", to_i);
            int to_wire = potential_dest_wires[to_i].wire;

            for(int from_i = 0; from_i < to_from_index[to_i].size(); from_i++){
                int src_wire_ind = to_from_index[to_i][from_i];
                int from_wire = potential_src_wires[src_wire_ind].wire;
                e_direction from_wire_direction = from_chan_details[from_x][from_y][from_wire].direction();
                if (from_wire_direction == INC_DIRECTION) {
                    VTR_ASSERT(gsb_conn.from_side == BOTTOM || gsb_conn.from_side == LEFT);
                } else if (from_wire_direction == DEC_DIRECTION) {
                    VTR_ASSERT(gsb_conn.from_side == TOP || gsb_conn.from_side == RIGHT);
                } else {
                    vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "compute_gsb_from_connections_seg : Can't support bi-direction wire");
                }

                t_gsb_edge gsb_edge;
                gsb_edge.from_wireOrpin = from_wire;
                gsb_edge.to_wireOrpin = to_wire;
                gsb_edge.switch_ind = to_chan_details[to_x][to_y][to_wire].arch_wire_switch();
                VTR_LOGV(verbose, "    index_conn: %d -> %d\t", src_wire_ind, to_i);
                VTR_LOGV(verbose, "    make_conn: %d -> %d switch=%d\n", gsb_edge.from_wireOrpin, gsb_edge.to_wireOrpin, gsb_edge.switch_ind);
                (*gsb_conns)[gsb_conn].push_back(gsb_edge);
            }
        }
    }
}

//gsbomux/pb
static void compute_gsb_from_connections_omuxOrpb(const DeviceGrid& grid, std::vector<t_wire_switchpoint> potential_dest_wires,
                                                const t_chan_details& to_chan_details, GSB_Lookup gsb_conn, int to_x, int to_y,
                                                const t_gsb_from_inf* gsb_from, t_gsb_connection_map* gsb_conns, int itg, 
                                                std::unordered_map<GSB_Side, std::vector<GSB_detail_conn_pb>, t_hash_GSB_side> detail_map,
                                                std::string actual_pbtype_name) {
    //segl1,l2...
    VTR_ASSERT(gsb_from->from_name.size() == 1);
    VTR_LOGV(verbose, "GSB_LOC: %d,%d omux/pb->%s\n", gsb_conn.x_coord, gsb_conn.y_coord, SIDE_STRING[gsb_conn.to_side]);
    VTR_LOGV(verbose, "from_type = omux/pb. from_name =%s\n", gsb_from->from_name[0].c_str());

    //Define to print out specific wire-switchpoints used in to/from sets, if verbose is set true
    #if 0
        VTR_LOGV(verbose, "  TO_SET: %s @", to_switchpoints.segment_name.c_str());
        for (int switchpoint : to_switchpoints.switchpoints) {
            VTR_LOGV(verbose, "%d ", switchpoint);
        }
        VTR_LOGV(verbose, "\n");
        vector<std::string> dst_wire_str;
        for (t_wire_switchpoint wire_switchpoint : potential_dest_wires) {
            dst_wire_str.push_back(std::to_string(wire_switchpoint.wire) + "@" + std::to_string(wire_switchpoint.switchpoint));
        }
        auto dst_str = vtr::join(dst_wire_str, ", ");
        VTR_LOGV(verbose, "  DST_WIRES: %s\n", dst_str.c_str());
    #endif

    if (potential_dest_wires.size() == 0) 
        //Can't make any connections between empty sets
        return;

    int total_froms;

    if (gsb_from->total_froms == 999 && !gsb_from->_only_use_group){
        vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "compute_gsb_from_connections_omuxOrpb : total_froms must be specified for omux/pb with not only_use_group!");
    }                                                                           
    
    total_froms = gsb_from->total_froms;

    std::vector<std::vector<int>> to_from_index;
    if ( !gsb_from->_only_detail ){
        if(gsb_conn.from_type == e_from_type::FT_OMUX){
            //to_index_in_potential_wires -> [omux_pin_index]([0..to_nums-1][0..num_foreach-1])
            to_from_index = get_from_index_for_gsb(gsb_from, total_froms, potential_dest_wires.size(), itg);
        }
        else{
            VTR_ASSERT(gsb_conn.from_type == e_from_type::FT_PB);
            //to_index_in_potential_wires -> [clb_pin_index]([0..to_nums-1][0..num_foreach-1])
            //pb_typepin
            auto clb_type = find_pb_type(actual_pbtype_name.c_str());
            to_from_index = get_from_index_for_gsb_pb(gsb_from, total_froms, potential_dest_wires.size(), clb_type, itg);
        }
    }
    
    VTR_LOGV(verbose, "num_to: %zu\n", to_from_index.size());
    for(int to_i = 0; to_i < to_from_index.size(); to_i++){
        int to_wire = potential_dest_wires[to_i].wire;

        for(int from_i = 0; from_i < to_from_index[to_i].size(); from_i++){
            int src_omuxOrclb_pin_ind = to_from_index[to_i][from_i];
            t_gsb_edge gsb_edge;
            gsb_edge.from_wireOrpin = src_omuxOrclb_pin_ind;
            gsb_edge.to_wireOrpin = to_wire;
            gsb_edge.switch_ind = to_chan_details[to_x][to_y][to_wire].arch_wire_switch();
            VTR_LOGV(verbose, "    index_conn: %d -> %d\t", src_omuxOrclb_pin_ind, to_i);
            VTR_LOGV(verbose, "    make_conn: %d -> %d switch=%d\n", gsb_edge.from_wireOrpin, gsb_edge.to_wireOrpin, gsb_edge.switch_ind);
            (*gsb_conns)[gsb_conn].push_back(gsb_edge);
        }
    }

    //pbdetail
    if(gsb_conn.from_type == e_from_type::FT_PB){
        auto detail_vec = detail_map[{gsb_conn.from_side, gsb_conn.to_side}];
        VTR_LOGV(verbose, "num_to(detail): %zu\n", detail_vec.size());
        for(auto const& detail : detail_vec){
            int to_wire = potential_dest_wires[detail.to_input].wire;
            t_gsb_edge gsb_edge;
            gsb_edge.from_wireOrpin = detail.from_output;
            gsb_edge.to_wireOrpin = to_wire;
            gsb_edge.switch_ind = to_chan_details[to_x][to_y][to_wire].arch_wire_switch();
            VTR_LOGV(verbose, "    index_conn: %d -> %d\t", detail.from_output, detail.to_input);
            VTR_LOGV(verbose, "    make_conn: %d -> %d switch=%d\n", gsb_edge.from_wireOrpin, gsb_edge.to_wireOrpin, gsb_edge.switch_ind);
            (*gsb_conns)[gsb_conn].push_back(gsb_edge);
        }        
    }
}


static std::vector<t_wire_switchpoint> get_switchpoint_wires_gsb(const DeviceGrid& grid, const t_chan_seg_details* chan_details, t_rr_type chan_type,
                                                                    int x, int y, e_side side, const t_wire_switchpoints& wire_switchpoints, 
                                                                    t_wire_type_sizes* wire_type_sizes, bool is_dest) {
    std::vector<t_wire_switchpoint> collected_wire_switchpoints;

    int seg_coord = x;
    if (chan_type == CHANY) {
        seg_coord = y;
    }

    const auto& wire_type = wire_switchpoints.segment_name;
    const auto& points = wire_switchpoints.switchpoints;

    if ((*wire_type_sizes).find(wire_type) == (*wire_type_sizes).end()) {
        vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "can't find wire_type %s for gsb", wire_type.c_str());
    }
    /* get the number of wires of given type */
    int num_type_wires = wire_type_sizes->at(wire_type).num_wires;
    /* get the last wire belonging to this type */
    int first_type_wire = wire_type_sizes->at(wire_type).start;
    int last_type_wire = first_type_wire + num_type_wires - 1;

    /* Walk through each wire segment of specified type and check whether it matches one
     * of the specified switchpoints.
     *
     * Note that we walk through the points in order, this ensures that returned switchpoints
     * match the order specified in the architecture, which we assume is a priority order specified
     * by the archtitect.
     */
    for (int valid_switchpoint : points) {
        for (int iwire = first_type_wire; iwire <= last_type_wire; iwire++) {
            e_direction seg_direction = chan_details[iwire].direction();
            /* unidirectional wires going in the decreasing direction can have an outgoing edge
             * only from the top or right switch block sides, and an incoming edge only if they are
             * at the left or bottom sides (analogous for wires going in INC direction) */
            if (side == TOP || side == RIGHT) {
                if (seg_direction == DEC_DIRECTION && is_dest) {
                    continue;
                }
                if (seg_direction == INC_DIRECTION && !is_dest) {
                    continue;
                }
            } else {
                VTR_ASSERT(side == LEFT || side == BOTTOM);
                if (seg_direction == DEC_DIRECTION && !is_dest) {
                    continue;
                }
                if (seg_direction == INC_DIRECTION && is_dest) {
                    continue;
                }
            }

            int wire_switchpoint = get_switchpoint_of_wire_gsb(grid, chan_type, chan_details[iwire], seg_coord, side);

            /* check if this wire belongs to one of the specified switchpoints; add it to our 'wires' vector if so */
            if (wire_switchpoint != valid_switchpoint) continue;

            collected_wire_switchpoints.push_back({iwire, wire_switchpoint});
        }
    }

    return collected_wire_switchpoints;
}

t_type_ptr find_pb_type(std::string pb_type_name){
    auto& device_ctx = g_vpr_ctx.device();
    int j;

    for (j = 0; j < device_ctx.num_block_types; j++) {
        if (strcmp(device_ctx.block_types[j].name, pb_type_name.c_str()) == 0) {
            break;
        }
    }
    if (j >= device_ctx.num_block_types) {
        vpr_throw(VPR_ERROR_ARCH, get_arch_file_name(), 0, "Unable to find block %s.\n", pb_type_name.c_str());
    }

    return &device_ctx.block_types[j];
}


//*****************************************for gsb two stage mux****************************************
static void compute_two_stage_mux_map(int x_coord, int y_coord, 
                                      const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                                      t_gsb_inf* gsb,
                                      const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, 
                                      t_two_stage_mux_map* two_stage_mux_map,
                                      const t_potential_wires_map& potential_wires_map,
                                      const std::map<std::string, std::vector<std::map<int, int>>> other_pbpin_to_clbpin_map,
                                      const std::map<std::string, int>& stage_mux_medium_map,
                                      const std::map<int, int>& clbpin_medium_map,
                                      int wire_to_arch_ipin_switch) {
    t_two_stage_mux_inf two_stage_mux_inf;

    auto& device_ctx = g_vpr_ctx.device();

    auto const& fsms = gsb->first_stages;
    auto const& ssms = gsb->second_stages;
    two_stage_mux_inf.first_stages.reserve(fsms.size());
    two_stage_mux_inf.second_stages.reserve(ssms.size());

    int switch_id = gsb->arch_gsb_switch_id;
    int medium_type = 0;
    //first stage
    int medium_ind;
    for(auto const& fsm : fsms){
        t_stage_mux_inf sm;
        auto it = stage_mux_medium_map.find(fsm.mux_name);
        VTR_ASSERT(it != stage_mux_medium_map.end());
        medium_ind = it->second;
        sm.to_node = device_ctx.medium_rr_node_indices[x_coord][y_coord][medium_type][0][medium_ind];//2-gsb
        sm.from_nodes = get_from_node_for_multistage_mux_v2(x_coord, y_coord, chan_details_x, chan_details_y,
                                                         grid, wire_type_sizes, fsm.from_infs, gsb->pbtype_names[0], other_pbpin_to_clbpin_map,
                                                         potential_wires_map, clbpin_medium_map);
        sm.to_switch = switch_id;

        for (auto const& mux_name : fsm.firststage_mux_name) {
            auto it = stage_mux_medium_map.find(mux_name);
            if(it == stage_mux_medium_map.end()){
                vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "Error from mux_name %s\n", mux_name.c_str());
            }
            //VTR_ASSERT(it != stage_mux_medium_map.end());
            medium_ind = it->second;
            sm.from_nodes.push_back(device_ctx.medium_rr_node_indices[x_coord][y_coord][medium_type][0][medium_ind]); //2-gsb
            //int node = device_ctx.medium_rr_node_indices[x_coord][y_coord][medium_type][0][medium_ind];
            //int j=0;
        }
        //sm.gsb_medium_id = fsm.medium_id;
        two_stage_mux_inf.first_stages.push_back(sm);
    }

    //second stage

    for (auto const& ssm : ssms) {
        t_stage_mux_inf sm;

        if(!ssm.to_pin_name.empty()){
            std::string port_name;
            t_type_ptr clb_type;
            int port_index, port_pin_index, clb_pin_index;

            //t_stage_mux_inf sm;

            //find to_node
            port_name = ssm.to_pin_name;
            clb_type = find_pb_type(gsb->pbtype_names[0]); //pb
            port_index = find_port(port_name, clb_type->pb_type);
            VTR_ASSERT(clb_type->pb_type->ports[port_index].type == IN_PORT);
            port_pin_index = ssm.to_ind;
            get_blk_pin_from_port_pin(clb_type->index, port_index, port_pin_index, &clb_pin_index);

            auto it = clbpin_medium_map.find(clb_pin_index);
            VTR_ASSERT(it != clbpin_medium_map.end());
            medium_ind = it->second;
            sm.to_node = device_ctx.medium_rr_node_indices[x_coord][y_coord][medium_type][0][medium_ind];
            if (sm.to_node == OPEN)
                VPR_THROW(VPR_ERROR_ROUTE, "find gsb multistage mux from_node OPEN in compute_multistage_mux_map, from_opin = %s:%d.\n", port_name.c_str(), port_pin_index);
            sm.to_switch = wire_to_arch_ipin_switch;

            sm.from_nodes = get_from_node_for_multistage_mux_v2(x_coord, y_coord, chan_details_x, chan_details_y,
                                                                grid, wire_type_sizes, ssm.from_infs, gsb->pbtype_names[0],
                                                                other_pbpin_to_clbpin_map, potential_wires_map, clbpin_medium_map);

            for (auto const& mux_name : ssm.firststage_mux_name) {
                auto it = stage_mux_medium_map.find(mux_name);
                if(it == stage_mux_medium_map.end()){
                    vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "Error from mux_name %s\n", mux_name.c_str());
                }
                //VTR_ASSERT(it != stage_mux_medium_map.end());
                medium_ind = it->second;
                sm.from_nodes.push_back(device_ctx.medium_rr_node_indices[x_coord][y_coord][medium_type][0][medium_ind]); //2-gsb
                //int node = device_ctx.medium_rr_node_indices[x_coord][y_coord][medium_type][0][medium_ind];
                //int j=0;
            }
            two_stage_mux_inf.second_stages.push_back(sm);


        } else{
            //find to_node
            t_wire_switchpoints to_switchpoints;
            to_switchpoints.segment_name = ssm.to_name;
            to_switchpoints.switchpoints = {0};

            e_side to_side = ssm.to_side;
            int to_track = ssm.to_ind;

            auto it = potential_wires_map.find(make_pair(to_side, to_switchpoints));
            VTR_ASSERT(it != potential_wires_map.end());
            const t_potential_wires& potential_dest_wires = (it->second)[1];
            if(potential_dest_wires.potential_wires.size() == 0)
                continue;
            VTR_ASSERT(to_track <= potential_dest_wires.potential_wires.size());
            int to_wire = potential_dest_wires.potential_wires[to_track].wire;
            e_rr_type to_chan_type = (to_side == LEFT || to_side == RIGHT) ? CHANX : CHANY;
            auto const& to_chan_details = to_chan_type == CHANX ? chan_details_x : chan_details_y;
            sm.to_node = get_rr_node_index(device_ctx.rr_node_indices, potential_dest_wires.x, potential_dest_wires.y, to_chan_type, to_wire);
            if (sm.to_node == OPEN) {
                VPR_THROW(VPR_ERROR_ROUTE, "find gsb multistage mux to_node OPEN in compute_two_stage_mux_map, to_track = %d.\n", to_track);
            }
            sm.to_switch = to_chan_details[potential_dest_wires.x][potential_dest_wires.y][to_wire].arch_wire_switch();

            sm.from_nodes = get_from_node_for_multistage_mux_v2(x_coord, y_coord, chan_details_x, chan_details_y,
                                                                grid, wire_type_sizes, ssm.from_infs, gsb->pbtype_names[0],
                                                                other_pbpin_to_clbpin_map, potential_wires_map, clbpin_medium_map);

            for(auto const&mux_name : ssm.firststage_mux_name){
                auto it = stage_mux_medium_map.find(mux_name);
                if(it == stage_mux_medium_map.end()){
                    vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "Error from mux_name %s\n", mux_name.c_str());
                }
                //VTR_ASSERT(it != stage_mux_medium_map.end());
                medium_ind = it->second;
                sm.from_nodes.push_back(device_ctx.medium_rr_node_indices[x_coord][y_coord][medium_type][0][medium_ind]); //2-gsb
            }
            two_stage_mux_inf.second_stages.push_back(sm);
        }


    }


    GSB_Lookup gsb_ms(x_coord, y_coord, e_from_type::NUM_FT_TYPES, NUM_SIDES, NUM_SIDES); /* for indexing into FPGA's switchblock map */
    (*two_stage_mux_map)[gsb_ms] = two_stage_mux_inf;
}

//nodepbpbpinindextilepb
static std::vector<int> get_from_node_for_multistage_mux_v2(int x_coord, int y_coord, const t_chan_details& chan_details_x, const t_chan_details& chan_details_y,
                                                         const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, std::vector<t_mux_same_from_inf> from_mux_inf,
                                                         const std::string first_pb_name, const std::map<std::string, std::vector<std::map<int, int>>> other_pbpin_to_clbpin_map,
                                                         const t_potential_wires_map& potential_wires_map, const std::map<int, int>& clbpin_medium_map) {
    std::vector<int> medium_from_nodes;

    auto& device_ctx = g_vpr_ctx.device();

    bool is_other_tile = false;
    auto type = grid[x_coord][y_coord].type;
    std::string pbtype_name = type->name;
    auto iter = other_pbpin_to_clbpin_map.find(pbtype_name);
    if (iter != other_pbpin_to_clbpin_map.end()) {
        is_other_tile = true;
    }

    int from_x, from_y;//for neighbourhood

    for (auto const& same_from : from_mux_inf) {
        from_x = x_coord + same_from.x_offset;
        from_y = y_coord + same_from.y_offset;
        if (same_from.mux_from_type == e_from_type::FT_SEGMENT) {
            t_wire_switchpoints from_switchpoints;
            from_switchpoints.segment_name = same_from.from_name;
            from_switchpoints.switchpoints = {same_from.switchpoint};

            int from_track, from_wire;
            e_side from_side;
            e_rr_type from_chan_type;
            for (int i = 0; i < same_from.from_inds.size(); i++) {
                from_side = same_from.from_sides[i];
                from_track = same_from.from_inds[i];
                auto it = potential_wires_map.find(make_pair(from_side, from_switchpoints));
                if (it == potential_wires_map.end())
                    vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "Error switchpoints in get_from_node_for_multistage_mux_v2\n");
                //VTR_ASSERT(it != potential_wires_map.end());
                const t_potential_wires& potential_src_wires = (it->second)[0];//0-from 1-to
                if(potential_src_wires.potential_wires.size() == 0)
                    continue;
                VTR_ASSERT(from_track <= potential_src_wires.potential_wires.size());
                from_wire = potential_src_wires.potential_wires[from_track].wire;
                from_chan_type = (from_side == LEFT || from_side == RIGHT) ? CHANX : CHANY;
                auto const& from_chan_details = from_chan_type == CHANX ? chan_details_x : chan_details_y;

                int from_node = get_rr_node_index(device_ctx.rr_node_indices, potential_src_wires.x, potential_src_wires.y, from_chan_type, from_wire);
                if (from_node == OPEN)
                    continue;
                    //VPR_THROW(VPR_ERROR_ROUTE, "find gsb multistage mux from_node OPEN in compute_multistage_mux_map, from_track = %d.\n", same_from.from_inds[i]);
                medium_from_nodes.push_back(from_node);
            }

        } else if (same_from.mux_from_type == e_from_type::FT_PB) {
            if (from_x < 0 || from_x > grid.width() - 1 || from_y < 0 || from_y > grid.height() - 1)
                continue;

            bool is_other_tile = false;
            auto type = grid[from_x][from_y].type;
            std::string pbtype_name = type->name;
            auto iter = other_pbpin_to_clbpin_map.find(pbtype_name);
            if (iter != other_pbpin_to_clbpin_map.end()) {
                is_other_tile = true;
            }

            if(!is_other_tile && pbtype_name != first_pb_name)//skip if this pb is not gsb arch
                continue;

            for (int j = 0; j < same_from.from_inds.size(); j++) {
                std::string port_name = same_from.from_pin_types[j];
                auto clb_type = find_pb_type(first_pb_name); //pb
                int port_index = find_port(port_name, clb_type->pb_type);
                VTR_ASSERT(clb_type->pb_type->ports[port_index].type == OUT_PORT);
                int port_pin_index = same_from.from_inds[j];
                int clb_pin_index;
                get_blk_pin_from_port_pin(clb_type->index, port_index, port_pin_index, &clb_pin_index);

                if (is_other_tile) {
                    int index = grid[from_x][from_y].width_offset * type->height + grid[from_x][from_y].height_offset;
                    auto const pbpin_to_clbpin_map_tile = (iter->second)[index];
                    auto iter2 = pbpin_to_clbpin_map_tile.find(clb_pin_index);
                    if (iter2 != pbpin_to_clbpin_map_tile.end()) {
                        clb_pin_index = iter2->second;
                    } else {
                        continue;
                    }
                }

                if(clb_pin_index >= type->num_pins)
                    continue;

                int from_node;
                for (auto side : SIDES) {
                    from_node = get_rr_node_index(device_ctx.rr_node_indices, from_x, from_y, OPIN, clb_pin_index, side);
                    if (from_node != OPEN)
                        break;
                }
                if (from_node == OPEN)
                    VPR_THROW(VPR_ERROR_ROUTE, "find gsb multistage mux from_node OPEN in compute_multistage_mux_map, from_opin = %s:%d.\n", port_name.c_str(), port_pin_index);
                medium_from_nodes.push_back(from_node);
            }
        } else if (same_from.mux_from_type == e_from_type::FT_IMUX) {
            std::string port_name;
            t_type_ptr clb_type;
            int port_index, port_pin_index, clb_pin_index, medium_ind;
            int from_node;
            for (int j = 0; j < same_from.from_inds.size(); j++) {
                //find from_nodes
                port_name = same_from.from_pin_types[j];
                clb_type = find_pb_type(first_pb_name); //pb
                port_index = find_port(port_name, clb_type->pb_type);
                VTR_ASSERT(clb_type->pb_type->ports[port_index].type == IN_PORT);
                port_pin_index = same_from.from_inds[j];
                get_blk_pin_from_port_pin(clb_type->index, port_index, port_pin_index, &clb_pin_index);

                auto it = clbpin_medium_map.find(clb_pin_index);
                VTR_ASSERT(it != clbpin_medium_map.end());
                medium_ind = it->second;
                from_node = device_ctx.medium_rr_node_indices[x_coord][y_coord][0][0][medium_ind];
                if (from_node == OPEN)
                    VPR_THROW(VPR_ERROR_ROUTE, "find gsb multistage mux from_node OPEN in compute_multistage_mux_map, from_opin = %s:%d.\n", port_name.c_str(), port_pin_index);
                medium_from_nodes.push_back(from_node);
            }
        }
        else{
            vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "Error multistage in compute_multistage_mux_map\n");
        }
    }

    return medium_from_nodes;
}

static void build_wire_map(int x_coord, int y_coord, const DeviceGrid& grid, 
                            const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                            const std::vector<t_segment_inf>& segment_inf, t_wire_type_sizes* wire_type_sizes,
                            t_potential_wires_map& potential_wires_map) {
    int from_x, from_y;                     /* index into source channel */
    int to_x, to_y;                         /* index into destination channel */
    t_rr_type from_chan_type, to_chan_type; /* the type of channel - i.e. CHANX or CHANY */
    from_x = from_y = to_x = to_y = UNDEFINED;

    //std::unordered_map<std::pair<e_side, t_wire_switchpoints>, std::vector<std::vector<t_wire_switchpoint>>> m;
    t_wire_switchpoints switchpoints;
    for(auto const& seg : segment_inf){
        if(seg.frequency == 0.0)//3freqarch0
            continue;
        switchpoints.segment_name = seg.name;

        //for from, find all switchpoints
        for (int i = 0; i < seg.length; i++){
            switchpoints.switchpoints = {i};
            t_potential_wires potential_wires_inf;
            for (e_side side : SIDES) {
                //potential_wires_map[make_pair(side, switchpoints)].resize(2);//0-from, 1-to
                std::vector<t_potential_wires>& wires_map = potential_wires_map[make_pair(side, switchpoints)];
                wires_map.resize(2); //0-from, 1-to

                const t_chan_details& from_chan_details = index_into_correct_chan(x_coord, y_coord, side, chan_details_x, chan_details_y,
                                                                                  &from_x, &from_y, &from_chan_type);
                if (coords_out_of_bounds(grid, from_x, from_y, from_chan_type))
                    continue;
                std::vector<t_wire_switchpoint> potential_src_wires = get_switchpoint_wires_gsb(grid, from_chan_details[from_x][from_y].data(), from_chan_type, from_x, from_y, side,
                                                                                                switchpoints, wire_type_sizes, false);
                //VTR_ASSERT(to_track <= potential_dest_wires.size());
                //if (potential_src_wires.size() == 0)
                //    continue;
                potential_wires_inf.potential_wires = potential_src_wires;
                potential_wires_inf.x = from_x;
                potential_wires_inf.y = from_y;
                wires_map[0] = potential_wires_inf;
            }
        }

        //for to, only find switchpoints = 0(start)
        switchpoints.switchpoints = {0};
        t_potential_wires potential_wires_inf;
        for(e_side side : SIDES){
            //potential_wires_map[make_pair(side, switchpoints)].resize(2);//0-from, 1-to
            std::vector<t_potential_wires>& wires_map = potential_wires_map[make_pair(side, switchpoints)];
            wires_map.resize(2); //0-from, 1-to

            const t_chan_details& to_chan_details = index_into_correct_chan(x_coord, y_coord, side, chan_details_x, chan_details_y,
                                                                            &to_x, &to_y, &to_chan_type);
            if (coords_out_of_bounds(grid, to_x, to_y, to_chan_type))
                continue;
            std::vector<t_wire_switchpoint> potential_dest_wires = get_switchpoint_wires_gsb(grid, to_chan_details[to_x][to_y].data(), to_chan_type, to_x, to_y, side,
                                                                                             switchpoints, wire_type_sizes, true);
            //VTR_ASSERT(to_track <= potential_dest_wires.size());
            //if (potential_dest_wires.size() == 0)
            //    continue;
            potential_wires_inf.potential_wires = potential_dest_wires;
            potential_wires_inf.x = to_x;
            potential_wires_inf.y = to_y;
            wires_map[1] = potential_wires_inf;
        }
    }
}

t_two_stage_mux_map* alloc_and_load_two_stage_map(const t_chan_details& chan_details_x,
                                                                                   const t_chan_details& chan_details_y,
                                                                                   const DeviceGrid& grid,
                                                                                   std::vector<t_gsb_inf> gsb_fs,
                                                                                   const std::vector<t_segment_inf>& segment_inf,
                                                                                   t_chan_width* nodes_per_chan,
                                                                                   const std::map<std::string, std::vector<std::map<int, int>>>& other_pbpin_to_clbpin_map,
                                                                                   const std::map<std::string, int>& gsb_stage_mux_medium_map,
                                                                                   const std::map<int, int>& clbpin_medium_map,
                                                                                   int wire_to_arch_ipin_switch) {
    /* get a single number for channel width */
    int channel_width = nodes_per_chan->max;
    if (nodes_per_chan->max != nodes_per_chan->x_min || nodes_per_chan->max != nodes_per_chan->y_min) {
        vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "gsb currently support consistent channel widths only.");
    }

    /* sparse array that will contain switch block connections */
    t_two_stage_mux_map* gsb_two_stage_map = new t_two_stage_mux_map;
    //t_two_stage_mux_map* imux_two_stage_map = new t_two_stage_mux_map;

    /* We assume that x & y channels have the same ratios of wire types. i.e., looking at a single
     * channel is representative of all channels in the FPGA -- as of 3/9/2013 this is true in VPR */
    t_wire_type_sizes wire_type_sizes;
    count_wire_type_sizes(chan_details_x[0][0].data(), channel_width, &wire_type_sizes);

    /* iterate over all the gsb specified in the architecture */
    for (int i_gsb = 0; i_gsb < (int)gsb_fs.size(); i_gsb++) {
        t_gsb_inf gsb = gsb_fs[i_gsb];
        //t_imux_inf imux = imux_fs[i_gsb];

        /* Iterate over the x,y coordinates spanning the FPGA. */
        for (size_t x_coord = 0; x_coord < grid.width(); x_coord++) {
            for (size_t y_coord = 0; y_coord < grid.height(); y_coord++) {
                t_type_ptr type = grid[x_coord][y_coord].type;
                bool is_gsb_arch = false;
                for (auto pb_name : gsb.pbtype_names) {
                    if (0 == strcmp(type->name, pb_name.c_str())) {
                        is_gsb_arch = true;
                        break;
                    }
                }

                if (is_gsb_arch) {
                    //wire
                    t_potential_wires_map potential_wires_map;
                    build_wire_map(x_coord, y_coord, grid, chan_details_x, chan_details_y, segment_inf, &wire_type_sizes, potential_wires_map);

                    /* now we iterate over all the potential side1->side2 connections */
                    VTR_LOGV(verbose, "***********************GSB two stage mux map compute *****************************\n");
                    compute_two_stage_mux_map(x_coord, y_coord, chan_details_x, chan_details_y,
                                              &gsb, grid, &wire_type_sizes, gsb_two_stage_map, potential_wires_map,
                                              other_pbpin_to_clbpin_map, gsb_stage_mux_medium_map, clbpin_medium_map,
                                              wire_to_arch_ipin_switch);

                }
            }
        }
    }
    return gsb_two_stage_map;
}

//**************************************************************for imux arch *********************************************************************************************
t_gsb_connection_map* alloc_and_load_imux_permutations(const t_chan_details& chan_details_x,
                                                             const t_chan_details& chan_details_y,
                                                             const DeviceGrid& grid,
                                                             vector<t_imux_inf> imux_fs,
                                                             t_chan_width* nodes_per_chan,
                                                             int wire_to_arch_ipin_switch) {
    /* get a single number for channel width */
    int channel_width = nodes_per_chan->max;
    if (nodes_per_chan->max != nodes_per_chan->x_min || nodes_per_chan->max != nodes_per_chan->y_min) {
        vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "gsb currently support consistent channel widths only.");
    }

    /* sparse array that will contain switch block connections */
    t_gsb_connection_map* gsb_conns = new t_gsb_connection_map;

    /* We assume that x & y channels have the same ratios of wire types. i.e., looking at a single
     * channel is representative of all channels in the FPGA -- as of 3/9/2013 this is true in VPR */
    t_wire_type_sizes wire_type_sizes;
    count_wire_type_sizes(chan_details_x[0][0].data(), channel_width, &wire_type_sizes);

    /* iterate over all the switchblocks specified in the architecture */
    for (int i_imux = 0; i_imux < (int)imux_fs.size(); i_imux++) {
        t_imux_inf imux = imux_fs[i_imux];

        //imuxlut[0..num_lut_group-1][0..num_lut-1][0..num_lut_input-1]
        //lut_group_ind(0,1) -> lut_ind(0.1.2.3) -> clb_pin_index_fro_this_lut
        std::vector<std::vector<std::vector<int>>> clb_ipin_index_group;
        compute_imux_group_dis(imux.pbtype_names[0], &imux, clb_ipin_index_group);//
        e_from_type from_type;

        //imuxsegx,y
        for (size_t x_coord = 0; x_coord < grid.width(); x_coord++) {
            for (size_t y_coord = 0; y_coord < grid.height(); y_coord++) {
                t_type_ptr type = grid[x_coord][y_coord].type;
                bool is_gsb_arch = false;
                for (auto pb_name : imux.pbtype_names) {
                    if (0 == strcmp(type->name, pb_name.c_str())) {
                        is_gsb_arch = true;
                        break;
                    }
                }

                /* now we iterate over all the potential side1->side2 connections */
                if(is_gsb_arch){
                    VTR_LOGV(verbose_imux, "***********************IMUX from_type : segment *****************************\n");
                    from_type = e_from_type::FT_SEGMENT;
                    compute_imux_wire_connections_seg(x_coord, y_coord, from_type, chan_details_x, chan_details_y, &imux, grid,
                                                        &wire_type_sizes, gsb_conns, wire_to_arch_ipin_switch, clb_ipin_index_group);
                }
            }
        }

        //x,yx,y
        for (size_t x_coord = 0; x_coord < grid.width(); x_coord++) {
            for (size_t y_coord = 0; y_coord < grid.height(); y_coord++) {
                t_type_ptr type = grid[x_coord][y_coord].type;
                bool is_gsb_arch = false;
                if (0 == strcmp(type->name, imux.pbtype_names[0].c_str()))//pbpb 
                    is_gsb_arch = true;

                if (is_gsb_arch) {
                    VTR_LOGV(verbose_imux, "***********************IMUX from_type : omux *****************************\n");
                    from_type = e_from_type::FT_OMUX;
                    compute_imux_wire_connections_omux(x_coord, y_coord, from_type, &imux, gsb_conns, clb_ipin_index_group, wire_to_arch_ipin_switch);

                    VTR_LOGV(verbose_imux, "***********************IMUX from_type : pb *****************************\n");
                    from_type = e_from_type::FT_PB;
                    compute_imux_wire_connections_pb(x_coord, y_coord, grid, from_type,
                                                     &imux, gsb_conns, clb_ipin_index_group, wire_to_arch_ipin_switch);

                    VTR_LOGV(verbose_imux, "***********************IMUX from_type : imux *****************************\n");
                    from_type = e_from_type::FT_IMUX;
                    compute_imux_wire_connections_pb(x_coord, y_coord, grid, from_type,
                                                     &imux, gsb_conns, clb_ipin_index_group, wire_to_arch_ipin_switch);
                    return gsb_conns;
                }
            }
        }
    }

    return gsb_conns;
}

//imuxlut[0..num_lut_group-1][0..num_lut-1][0..num_lut_input-1]
//lut_group_ind(0,1) -> lut_ind(0.1.2.3) -> clb_pin_index_fro_this_lut
static void compute_imux_group_dis(std::string pb_type_name, t_imux_inf* imux, std::vector<std::vector<std::vector<int>>>& clb_ipin_index_group){
    clb_ipin_index_group.resize(imux->imux_group_inf.size());
    for (int ig = 0; ig < (int)imux->imux_group_inf.size(); ig++) {
        const t_imux_group_inf* imux_g = &imux->imux_group_inf[ig];
        int ix_ind = 0;
        int i_port, end_pin_index;

        std::vector<std::vector<int>> clb_ipin_index;
        clb_ipin_index.resize(imux_g->lut_name.size());

        //i,x###########################################
        std::vector<std::string> str_vec = {"i", "x"};
        for(int i =0; i < imux_g->lut_name.size(); i++){
            auto port_name = imux_g->lut_name[i];
            auto clb_type = find_pb_type(pb_type_name);
            auto pb_type = clb_type->pb_type;
            int i_pin, clb_pin_ind;
            
            i_port = find_port(port_name, pb_type);
            for(i_pin = 0; i_pin < pb_type->ports[i_port].num_pins; i_pin++){
                get_blk_pin_from_port_pin(clb_type->index, i_port, i_pin, &clb_pin_ind);
                clb_ipin_index[i].push_back(clb_pin_ind);
            }


            char lut_char = port_name[1];
            i_pin = lut_char - 'a';//???
            //find corresponding i
            i_port = find_port(str_vec[0], pb_type);
            get_blk_pin_from_port_pin(clb_type->index, i_port, i_pin, &clb_pin_ind);
            clb_ipin_index[i].push_back(clb_pin_ind);

            //find corresponding x
            i_port = find_port(str_vec[1], pb_type);
            get_blk_pin_from_port_pin(clb_type->index, i_port, i_pin, &clb_pin_ind);
            clb_ipin_index[i].push_back(clb_pin_ind);

            VTR_ASSERT(clb_ipin_index[i].size() == imux_g->mux_nums_eachlut);
        }
        clb_ipin_index_group[ig] = clb_ipin_index;
    }
}

int find_port(std::string port_name, t_pb_type* pb_type){
    int i_port;
    for (i_port = 0; i_port < pb_type->num_ports; ++i_port) {
        if( 0 == strcmp(pb_type->ports[i_port].name, port_name.c_str())) break;
    }
    if (i_port >= pb_type->num_ports) {
        vpr_throw(VPR_ERROR_ARCH, get_arch_file_name(), 0, "Unable to find port %s (on pb_type %s).\n", port_name.c_str(), pb_type->name);
    }
    return i_port;
}

static void compute_imux_wire_connections_seg(int x_coord, int y_coord, enum e_from_type from_type, 
                                                const t_chan_details& chan_details_x, const t_chan_details& chan_details_y, 
                                                t_imux_inf* imux, const DeviceGrid& grid, t_wire_type_sizes* wire_type_sizes, 
                                                t_gsb_connection_map* gsb_conns, int wire_to_arch_ipin_switch,
                                                const std::vector<std::vector<std::vector<int>>>& clb_ipin_index_group) {
    int from_x, from_y;                     /* index into source channel */
    t_rr_type from_chan_type, to_chan_type; /* the type of channel - i.e. CHANX or CHANY */
    from_x = from_y = UNDEFINED;
    for (int ig = 0; ig < (int)imux->imux_group_inf.size(); ig++) {
        const t_imux_group_inf* imux_g = &imux->imux_group_inf[ig];

        auto const& clb_ipin_index = clb_ipin_index_group[ig];

        VTR_LOGV(verbose_imux, "GROUP %d. to_lut\n", ig);
        for (int ig_f = 0; ig_f < (int)imux_g->imux_from_inf.size(); ig_f++) {
            const t_imux_from_inf* imux_f = &imux_g->imux_from_inf[ig_f];
            if(imux_f->from_type != from_type) continue;

            //for gsb: {from_side, NUM_SIDES} -> {from_index_in_potential_wires, to_lut_pin_index}
            //to_lut_pin_indexlutclb_ipin_index_groupclb_pin_index
            std::unordered_map<GSB_Side, std::vector<GSB_detail_conn>, t_hash_GSB_side> detail_map;
            if(imux_f->_imux_detail_inf.size()>0){
                detail_map = get_detail_index_for_gsb(imux_f);
            }

            e_side to_side = NUM_SIDES;
            for (e_side from_side : {TOP, RIGHT, BOTTOM, LEFT}) {
                GSB_Lookup gsb_conn(x_coord, y_coord, from_type, from_side, to_side); /* for indexing into FPGA's switchblock map */

                /* details for source channel */
                const t_chan_details& from_chan_details = index_into_correct_chan(x_coord, y_coord, from_side, chan_details_x, chan_details_y,
                                                                          &from_x, &from_y, &from_chan_type);
                
                /* make sure from_x/y and to_x/y aren't out of bounds */
                if (coords_out_of_bounds(grid, from_x, from_y, from_chan_type)) 
                    continue;

                compute_imux_from_connections_seg(grid, clb_ipin_index, from_chan_details,
                                                    gsb_conn, from_x, from_y, from_chan_type, wire_type_sizes,
                                                    imux_f, detail_map, gsb_conns, wire_to_arch_ipin_switch);
            }
            
        }
    }
    return;
}

static void compute_imux_from_connections_seg(const DeviceGrid& grid, std::vector<std::vector<int>> potential_dest_pins_lut,
                                                const t_chan_details& from_chan_details, GSB_Lookup gsb_conn, int from_x, int from_y,  
                                                t_rr_type from_chan_type, t_wire_type_sizes* wire_type_sizes, const t_common_from_inf* gsb_from,
                                                std::unordered_map<GSB_Side, std::vector<GSB_detail_conn>, t_hash_GSB_side> detail_map, 
                                                t_gsb_connection_map* gsb_conns, int wire_to_arch_ipin_switch) {
    //constexpr bool verbose_imux = true;
    for(auto const& name : gsb_from->from_name){
        t_wire_switchpoints from_switchpoints;
        from_switchpoints.segment_name = name;
        from_switchpoints.switchpoints = gsb_from->from_switchpoints;

        //srcfrom_sideswitchpointwire
        std::vector<t_wire_switchpoint> potential_src_wires = get_switchpoint_wires_gsb(grid, from_chan_details[from_x][from_y].data(), from_chan_type, from_x, from_y, gsb_conn.from_side,
                                                                                from_switchpoints, wire_type_sizes, false);

        VTR_LOGV(verbose_imux, "IMUX_LOC: %d,%d %s->%s\n", gsb_conn.x_coord, gsb_conn.y_coord, SIDE_STRING[gsb_conn.from_side], SIDE_STRING[gsb_conn.to_side]);
        VTR_LOGV(verbose_imux, "from_type = segment. from_name =%s\n", name.c_str());

        if (potential_src_wires.size() == 0 || potential_dest_pins_lut.size() == 0) 
            //Can't make any connections between empty sets
            return;

        /* At this point the vectors 'potential_src_wires' and 'potential_dest_wires' contain the indices of the from_type/from_point
         * and to_type/to_point wire segments. Now we compute the connections between them, according to permutation functions */
        size_t src_W = potential_src_wires.size();
        int total_froms;

        if (gsb_from->total_froms == 999){
            VTR_ASSERT(gsb_from->from_start == 0);
            total_froms = potential_src_wires.size();
        }
        else{                                                                           
            VTR_ASSERT(gsb_from->from_start + gsb_from->total_froms <= src_W);
            total_froms = gsb_from->total_froms;
        }

        auto detail_vec = detail_map[{gsb_conn.from_side, gsb_conn.to_side}];
        VTR_LOGV(verbose_imux, "num_to(detail): %zu\n", detail_vec.size());
        for(auto const& detail : detail_vec){
            VTR_LOGV(verbose_imux, "    index_conn: %d -> %d\n", detail.from_output, detail.to_input);
            for(auto potential_dest_pins : potential_dest_pins_lut){
                int to_pin = potential_dest_pins[detail.to_input];
                int from_wire = potential_src_wires[detail.from_output].wire;
                e_direction from_wire_direction = from_chan_details[from_x][from_y][from_wire].direction();
                if (from_wire_direction == INC_DIRECTION) {
                    VTR_ASSERT(gsb_conn.from_side == BOTTOM || gsb_conn.from_side == LEFT);
                } else if (from_wire_direction == DEC_DIRECTION) {
                    VTR_ASSERT(gsb_conn.from_side == TOP || gsb_conn.from_side == RIGHT);
                } else {
                    vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "compute_gsb_from_connections_seg : Can't support bi-direction wire");
                }
                t_gsb_edge gsb_edge;
                gsb_edge.from_wireOrpin = from_wire;
                gsb_edge.to_wireOrpin = to_pin;
                gsb_edge.switch_ind = wire_to_arch_ipin_switch;
                VTR_LOGV(verbose_imux, "    make_conn: %d -> %d switch=%d\n", gsb_edge.from_wireOrpin, gsb_edge.to_wireOrpin, gsb_edge.switch_ind);
                (*gsb_conns)[gsb_conn].push_back(gsb_edge);
            }  
        }

        //lut_input_index(0..7) -> [from_index_in_potential_wires]([0..to_nums-1][0..num_foreach-1])
        std::vector<std::vector<int>> to_from_index;
        if ( !gsb_from->only_detail() ){
            to_from_index = get_from_index_for_gsb(gsb_from, total_froms, potential_dest_pins_lut[0].size(), 0);//lut
        }
        else{
            continue;
        }

        for(auto potential_dest_pins : potential_dest_pins_lut){
            VTR_LOGV(verbose_imux, "num_to: %zu\n", to_from_index.size());
            for(int to_i = 0; to_i < to_from_index.size(); to_i++){
                //VTR_LOGV(verbose_imux, "  to_index: %zu\n", to_i);
                int to_lut_pin = potential_dest_pins[to_i];

                for(int from_i = 0; from_i < to_from_index[to_i].size(); from_i++){
                    int src_wire_ind = to_from_index[to_i][from_i];
                    int from_wire = potential_src_wires[src_wire_ind].wire;
                    e_direction from_wire_direction = from_chan_details[from_x][from_y][from_wire].direction();
                    if (from_wire_direction == INC_DIRECTION) {
                        VTR_ASSERT(gsb_conn.from_side == BOTTOM || gsb_conn.from_side == LEFT);
                    } else if (from_wire_direction == DEC_DIRECTION) {
                        VTR_ASSERT(gsb_conn.from_side == TOP || gsb_conn.from_side == RIGHT);
                    } else {
                        vpr_throw(VPR_ERROR_ARCH, __FILE__, __LINE__, "compute_gsb_from_connections_seg : Can't support bi-direction wire");
                    }

                    t_gsb_edge gsb_edge;
                    gsb_edge.from_wireOrpin = from_wire;
                    gsb_edge.to_wireOrpin = to_lut_pin;
                    gsb_edge.switch_ind = wire_to_arch_ipin_switch;
                    VTR_LOGV(verbose_imux, "    index_conn: %d -> %d\t", src_wire_ind, to_i);
                    VTR_LOGV(verbose_imux, "    make_conn: %d -> %d switch=%d\n", gsb_edge.from_wireOrpin, gsb_edge.to_wireOrpin, gsb_edge.switch_ind);
                    (*gsb_conns)[gsb_conn].push_back(gsb_edge);
                }
            }
        }
        
    }
}


static void compute_imux_wire_connections_omux(int x_coord, int y_coord, enum e_from_type from_type, t_imux_inf* imux,
                                                t_gsb_connection_map* gsb_conns, const std::vector<std::vector<std::vector<int>>>& clb_ipin_index_group, 
                                                int wire_to_arch_ipin_switch) {
    for (int ig = 0; ig < (int)imux->imux_group_inf.size(); ig++) {
        const t_imux_group_inf* imux_g = &imux->imux_group_inf[ig];

        auto const& clb_ipin_index = clb_ipin_index_group[ig];

        VTR_LOGV(verbose_imux, "GROUP %d. to_lut\n", ig);
        for (int ig_f = 0; ig_f < (int)imux_g->imux_from_inf.size(); ig_f++) {
            const t_imux_from_inf* imux_f = &imux_g->imux_from_inf[ig_f];
            if(imux_f->from_type != from_type) continue;

            VTR_ASSERT(imux_f->_only_detail == false);

            GSB_Lookup gsb_conn(x_coord, y_coord, from_type, NUM_SIDES, NUM_SIDES); /* for indexing into FPGA's switchblock map */

            compute_imux_from_connections_omuxOrpb(clb_ipin_index, gsb_conn, imux_f, nullptr, gsb_conns, wire_to_arch_ipin_switch, {});
        }
    }
    return;
}

/*
static void compute_imux_from_connections_omux(std::vector<std::vector<int>> potential_dest_pins_lut,
                                                GSB_Lookup gsb_conn, const t_common_from_inf* gsb_from,
                                                t_gsb_connection_map* gsb_conns, int wire_to_arch_ipin_switch) {
    VTR_ASSERT(gsb_from->from_name.size() == 0);
    VTR_LOGV(verbose_imux, "GSB_LOC: %d,%d %s->%s\n", gsb_conn.x_coord, gsb_conn.y_coord, SIDE_STRING[gsb_conn.from_side], SIDE_STRING[gsb_conn.to_side]);
    VTR_LOGV(verbose_imux, "from_type = omux. from_name =%s\n", gsb_from->from_name[0].c_str());
        
    if (potential_dest_pins_lut.size() == 0) 
        return;

    VTR_ASSERT(gsb_from->total_froms != 999);
    int total_froms = gsb_from->total_froms;
    
    std::vector<std::vector<int>> to_from_index = get_from_index_for_gsb(gsb_from, total_froms, potential_dest_pins_lut[0].size(), 0);//lut
        

    for(auto potential_dest_pins : potential_dest_pins_lut){
        VTR_LOGV(verbose_imux, "num_to: %zu\n", to_from_index.size());
        for(int to_i = 0; to_i < to_from_index.size(); to_i++){
            int to_lut_pin = potential_dest_pins[to_i];

            for(int from_i = 0; from_i < to_from_index[to_i].size(); from_i++){
                int src_omux_ind = to_from_index[to_i][from_i];
                t_gsb_edge gsb_edge;
                gsb_edge.from_wireOrpin = src_omux_ind;
                    gsb_edge.to_wireOrpin = to_lut_pin;
                    gsb_edge.switch_ind = wire_to_arch_ipin_switch;
                    VTR_LOGV(verbose_imux, "    index_conn: %d -> %d\t", src_omux_ind, to_i);
                    VTR_LOGV(verbose_imux, "    make_conn: %d -> %d switch=%d\n", gsb_edge.from_wireOrpin, gsb_edge.to_wireOrpin, gsb_edge.switch_ind);
                    (*gsb_conns)[gsb_conn].push_back(gsb_edge);
            }
        }
    }
}
*/

static void compute_imux_wire_connections_pb(int x_coord, int y_coord, const DeviceGrid& grid, enum e_from_type from_type,
                                                t_imux_inf* imux, t_gsb_connection_map* gsb_conns, 
                                                const std::vector<std::vector<std::vector<int>>>& clb_ipin_index_group,
                                                int wire_to_arch_ipin_switch) {
    for (int ig = 0; ig < (int)imux->imux_group_inf.size(); ig++) {
        const t_imux_group_inf* imux_g = &imux->imux_group_inf[ig];
        
        auto const& clb_ipin_index = clb_ipin_index_group[ig];

        VTR_LOGV(verbose_imux, "GROUP %d. to_lut\n", ig);
        for (int ig_f = 0; ig_f < (int)imux_g->imux_from_inf.size(); ig_f++) {
            const t_imux_from_inf* imux_f = &imux_g->imux_from_inf[ig_f];
            if(imux_f->from_type != from_type) continue;

            VTR_ASSERT(0 == strcmp(grid[x_coord][y_coord].type->name, imux_f->from_name[0].c_str()));
            //pb_typepin
            auto clb_type = find_pb_type(imux->pbtype_names[0]);

            //{NUM_SIDES, NUM_SIDES} -> {clb_port_name, from_clb_pin_index, to_lut_pin_index}
            //to_lut_pin_indexlutclb_ipin_index_groupclb_pin_index
            std::unordered_map<GSB_Side, std::vector<GSB_detail_conn_pb>, t_hash_GSB_side> detail_map;
            if(imux_f->_imux_detail_inf.size()>0){
                detail_map = get_detail_index_for_gsb_pb(imux_f, clb_type);
            }

            GSB_Lookup gsb_conn(x_coord, y_coord, from_type, NUM_SIDES, NUM_SIDES); /* for indexing into FPGA's switchblock map */

            compute_imux_from_connections_omuxOrpb(clb_ipin_index, gsb_conn, imux_f, clb_type, gsb_conns, wire_to_arch_ipin_switch, detail_map);
        }
    }
    return;
}

static void compute_imux_from_connections_omuxOrpb(std::vector<std::vector<int>> potential_dest_pins_lut,
                                                   GSB_Lookup gsb_conn,
                                                   const t_common_from_inf* gsb_from,
                                                   t_type_ptr clb_type,
                                                   t_gsb_connection_map* gsb_conns,
                                                   int wire_to_arch_ipin_switch,
                                                   std::unordered_map<GSB_Side, std::vector<GSB_detail_conn_pb>, t_hash_GSB_side> detail_map) {
    //omux/pbfrom_name
    VTR_ASSERT(gsb_from->from_name.size() == 1);
    VTR_LOGV(verbose_imux, "IMUX_LOC: %d,%d %s->%s\n", gsb_conn.x_coord, gsb_conn.y_coord, SIDE_STRING[gsb_conn.from_side], SIDE_STRING[gsb_conn.to_side]);
    VTR_LOGV(verbose_imux, "from_type = omux/pb. from_name =%s\n", gsb_from->from_name[0].c_str());
        
    if (potential_dest_pins_lut.size() == 0) 
        return;

    VTR_ASSERT(gsb_from->total_froms != 999);
    int total_froms = gsb_from->total_froms;
    
    std::vector<std::vector<int>> to_from_index;
    if ( !gsb_from->only_detail() ){
        if(gsb_conn.from_type == e_from_type::FT_OMUX){
            //to_lut_pin_index -> [omux_pin_index]([0..to_nums-1][0..num_foreach-1])
            to_from_index = get_from_index_for_gsb(gsb_from, total_froms, potential_dest_pins_lut[0].size(), 0);//lut
        }
        else{
            VTR_ASSERT(gsb_conn.from_type == e_from_type::FT_PB || gsb_conn.from_type == e_from_type::FT_IMUX);
            //to_lut_pin_index -> [clb_pin_index]([0..to_nums-1][0..num_foreach-1])
            to_from_index = get_from_index_for_gsb_pb(gsb_from, total_froms, potential_dest_pins_lut[0].size(), clb_type, 0);
        }
    }

    for(auto potential_dest_pins : potential_dest_pins_lut){
        VTR_LOGV(verbose_imux, "num_to: %zu\n", to_from_index.size());
        for(int to_i = 0; to_i < to_from_index.size(); to_i++){
            int to_lut_pin = potential_dest_pins[to_i];
            for(int from_i = 0; from_i < to_from_index[to_i].size(); from_i++){
                int src_omuxOrclb_pin_ind = to_from_index[to_i][from_i];
                t_gsb_edge gsb_edge;
                gsb_edge.from_wireOrpin = src_omuxOrclb_pin_ind;
                gsb_edge.to_wireOrpin = to_lut_pin;
                gsb_edge.switch_ind = wire_to_arch_ipin_switch;
                VTR_LOGV(verbose_imux, "    index_conn: %d -> %d\t", src_omuxOrclb_pin_ind, to_i);
                VTR_LOGV(verbose_imux, "    make_conn: %d -> %d switch=%d\n", gsb_edge.from_wireOrpin, gsb_edge.to_wireOrpin, gsb_edge.switch_ind);
                (*gsb_conns)[gsb_conn].push_back(gsb_edge);
            }
        }
    }

    if(gsb_conn.from_type == e_from_type::FT_PB || gsb_conn.from_type == e_from_type::FT_IMUX){
        auto detail_vec = detail_map[{gsb_conn.from_side, gsb_conn.to_side}];
        VTR_LOGV(verbose_imux, "num_to(detail): %zu\n", detail_vec.size());
        for(auto const& detail : detail_vec){
            VTR_LOGV(verbose_imux, "    index_conn: %d -> %d\t", detail.from_output, detail.to_input);
            for(auto potential_dest_pins : potential_dest_pins_lut){
                int to_lut_pin = potential_dest_pins[detail.to_input];
                t_gsb_edge gsb_edge;
                gsb_edge.from_wireOrpin = detail.from_output;
                gsb_edge.to_wireOrpin = to_lut_pin;
                gsb_edge.switch_ind = wire_to_arch_ipin_switch;
                VTR_LOGV(verbose_imux, "    make_conn: %d -> %d switch=%d\n", gsb_edge.from_wireOrpin, gsb_edge.to_wireOrpin, gsb_edge.switch_ind);
                (*gsb_conns)[gsb_conn].push_back(gsb_edge);
            
            }
        }
                
    }
}

//*********************************************for omux arch *********************************
//omux_name -> { omux_pin_index -> [omux_edge]}   omux_edge = {from_clb_pin_index, to_omux_pin_index, switch_id}
t_omux_connection_map* alloc_and_load_omux_permutations(vector<t_omux_inf> omux_fs) {
    auto& device_ctx = g_vpr_ctx.device();

    int i, j;
    std::string pb_type_name;

    t_omux_connection_map* omux_conns = new t_omux_connection_map;
    //std::vector<std::vector<int>> to_from_index;

    VTR_LOGV(verbose, "***********************OMUX *****************************\n");
    for (int i_omux = 0; i_omux < (int)omux_fs.size(); i_omux++) {
        t_omux_inf omux = omux_fs[i_omux];
        pb_type_name = omux.pbtype_names[0];//

        auto& to_from_index = (*omux_conns)[pb_type_name];
        std::map<int, int> out_port_map;//{port_index, num_pins}
        std::vector<int> clb_outpin_index;

        //auto clb_type = device_ctx.block_types[j];
        auto clb_type = find_pb_type(pb_type_name);
        auto pb_type = clb_type->pb_type;
        for (int i_port = 0; i_port < pb_type->num_ports; ++i_port) {
            auto port = pb_type->ports[i_port];
            if(port.type != OUT_PORT) continue;
            out_port_map[i_port] = port.num_pins;
        }

        //pin
        int clb_pin_index;
        int port_size = out_port_map.begin()->second;
        for(int i_pin = 0; i_pin < port_size; i_pin++){
            for(auto out_port : out_port_map){
                get_blk_pin_from_port_pin(clb_type->index, out_port.first, i_pin, &clb_pin_index);
                clb_outpin_index.push_back(clb_pin_index);
            }
        }

        VTR_ASSERT(omux.total_froms == clb_outpin_index.size());

        //assign clb out_pin to omux
        to_from_index.resize(omux.mux_nums);
        for(i = 0; i < omux.mux_nums; i++){
            for(j = 0; j < omux.num_foreach; j++){
                int index = (i * omux.num_foreach + j + omux.offset) % omux.total_froms;
                t_omux_edge oe;
                oe.from_pb_pin = clb_outpin_index[index];
                oe.to_omux_output = i;
                oe.switch_ind = omux.arch_omux_switch;
                to_from_index[i].push_back(oe);
            }
        }
    }

    VTR_LOGV(verbose, "omux_num = %d\n", (*omux_conns).size());
    for(auto vec : *omux_conns){
        VTR_LOGV(verbose, "pb = %s*******************************\n", vec.first.c_str());
        VTR_LOGV(verbose, "\tnum_to = %d\n", vec.second.size());
        for(i = 0; i < vec.second.size();i++){
            auto vec_f = vec.second[i];
            for(j = 0; j < vec_f.size(); j++){
                VTR_LOGV(verbose, "    make_conn: %d -> %d(omux_index) switch=%d\n"
                         "", vec_f[j].from_pb_pin, vec_f[j].to_omux_output, vec_f[j].switch_ind);
            }
        }
    }
    return omux_conns;
}

void free_omux_permutations(t_omux_connection_map * conns) {
    conns->clear();
    delete conns;
    conns = nullptr;
    /* the switch block unordered_map can get quite large and it doesn't seem like the program
     * is interested in releasing the memory back to the OS after the map is cleared.
     * calling malloc_trim forces the program to give unused heap space back to the OS.
     * this significantly reduces memory usage during the routing stage when running multiple
     * large benchmark circuits in parallel. */
    vtr::malloc_trim(0);
    return;
}

